{
  "address": "0xF1447b0fda912a6857B5d77d7cDE9663266896cf",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "unicrow_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "unicrowClaim_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "escrowId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "buyer",
              "type": "address"
            },
            {
              "internalType": "uint64",
              "name": "challengeExtension",
              "type": "uint64"
            },
            {
              "internalType": "address",
              "name": "seller",
              "type": "address"
            },
            {
              "internalType": "uint64",
              "name": "challengePeriodStart",
              "type": "uint64"
            },
            {
              "internalType": "address",
              "name": "marketplace",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "marketplaceFee",
              "type": "uint256"
            },
            {
              "internalType": "uint64",
              "name": "challengePeriodEnd",
              "type": "uint64"
            },
            {
              "internalType": "address",
              "name": "currency",
              "type": "address"
            },
            {
              "internalType": "uint16",
              "name": "claimed",
              "type": "uint16"
            },
            {
              "internalType": "int16[2]",
              "name": "consensus",
              "type": "int16[2]"
            },
            {
              "internalType": "uint16[4]",
              "name": "split",
              "type": "uint16[4]"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct Escrow",
          "name": "escrow",
          "type": "tuple"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "blockTime",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256[5]",
          "name": "amounts",
          "type": "uint256[5]"
        }
      ],
      "name": "Arbitrated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "escrowId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "arbitrator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "arbitratorFee",
          "type": "uint256"
        }
      ],
      "name": "ArbitratorApproved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "escrowId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "arbitrator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "arbitratorFee",
          "type": "uint16"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "proposer",
          "type": "address"
        }
      ],
      "name": "ArbitratorProposed",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "escrowId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "validationAddress",
          "type": "address"
        },
        {
          "internalType": "uint16",
          "name": "validation",
          "type": "uint16"
        }
      ],
      "name": "approveArbitrator",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "escrowId",
          "type": "uint256"
        },
        {
          "internalType": "uint16[2]",
          "name": "newSplit",
          "type": "uint16[2]"
        }
      ],
      "name": "arbitrate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16[5]",
          "name": "currentSplit",
          "type": "uint16[5]"
        }
      ],
      "name": "arbitrationCalculation",
      "outputs": [
        {
          "internalType": "uint16[5]",
          "name": "",
          "type": "uint16[5]"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "escrowArbitrator",
      "outputs": [
        {
          "internalType": "address",
          "name": "arbitrator",
          "type": "address"
        },
        {
          "internalType": "uint16",
          "name": "arbitratorFee",
          "type": "uint16"
        },
        {
          "internalType": "bool",
          "name": "sellerConsensus",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "buyerConsensus",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "arbitrated",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "escrowId",
          "type": "uint256"
        }
      ],
      "name": "getArbitratorData",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "arbitrator",
              "type": "address"
            },
            {
              "internalType": "uint16",
              "name": "arbitratorFee",
              "type": "uint16"
            },
            {
              "internalType": "bool",
              "name": "sellerConsensus",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "buyerConsensus",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "arbitrated",
              "type": "bool"
            }
          ],
          "internalType": "struct Arbitrator",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "escrowId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "arbitrator",
          "type": "address"
        },
        {
          "internalType": "uint16",
          "name": "arbitratorFee",
          "type": "uint16"
        }
      ],
      "name": "proposeArbitrator",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "escrowId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "arbitrator",
          "type": "address"
        },
        {
          "internalType": "uint16",
          "name": "arbitratorFee",
          "type": "uint16"
        }
      ],
      "name": "setArbitrator",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unicrow",
      "outputs": [
        {
          "internalType": "contract Unicrow",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unicrowClaim",
      "outputs": [
        {
          "internalType": "contract IUnicrowClaim",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xc9aec406ca73e9da2b11e9a5d9cb80c745b46a6a1e059582696713cfc70c43c6",
  "receipt": {
    "to": "0x81161454A163EbbA69F153e6919D1f986bbBd791",
    "from": "0x6Aa0d0671828FB7a66e080F06f91B453A696c40F",
    "contractAddress": "0xF1447b0fda912a6857B5d77d7cDE9663266896cf",
    "transactionIndex": 1,
    "gasUsed": "10175538",
    "logsBloom": "0x00000000400000000000000000000000000000000000000000000000040000000000000008000000000000000000000000000008000000000000000000000000000000000000000000000000020000000000040000000000000000000000000000000000000000000000000000000000000000000020000000010000000000000000000000000000000000000000000000000000000000000000004000000000000000000400000000000000000004000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa70d9e6d9cf39bba374cbf63d1b5e877c2942f26cb4df36f18442c1e0ea77749",
    "transactionHash": "0xc9aec406ca73e9da2b11e9a5d9cb80c745b46a6a1e059582696713cfc70c43c6",
    "logs": [
      {
        "transactionIndex": 1,
        "blockNumber": 51872239,
        "transactionHash": "0xc9aec406ca73e9da2b11e9a5d9cb80c745b46a6a1e059582696713cfc70c43c6",
        "address": "0x81161454A163EbbA69F153e6919D1f986bbBd791",
        "topics": [
          "0x66753cd2356569ee081232e3be8909b950e0a76c1f8460c3a5e3c2be32b11bed"
        ],
        "data": "0x0000000000000000000000007cbb62eaa69f79e6873cd1ecb2392971036cfaa40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000a7f29c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001c800000000000000000000000000000000000000000000000000000000000001d000000000000000000000000000000000000000000000000000000000000001ae44c8c9ea1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000001a7d60c06040523480156200001157600080fd5b5060405162001a3d38038062001a3d833981016040819052620000349162000075565b60016000556001600160601b0319606092831b8116608052911b1660a052620000ad565b80516001600160a01b03811681146200007057600080fd5b919050565b600080604083850312156200008957600080fd5b620000948362000058565b9150620000a46020840162000058565b90509250929050565b60805160601c60a05160601c6119336200010a6000396000818161025e015261075f01526000818161016601528181610322015281816103fd0152818161067c01528181610acb01528181610e60015261114a01526119336000f3fe608060405234801561001057600080fd5b50600436106100a35760003560e01c80636e4e2934116100765780638e032c5a1161005b5780638e032c5a146101b3578063e2bc475c146101c6578063e9db7d791461025957600080fd5b80636e4e29341461016157806379414b3c146101a057600080fd5b806316e0551b146100a85780632ea8eddd14610119578063496f928b1461012e5780634c403c5314610141575b600080fd5b6100bb6100b636600461150e565b610280565b6040516101109190600060a0820190506001600160a01b03835116825261ffff602084015116602083015260408301511515604083015260608301511515606083015260808301511515608083015292915050565b60405180910390f35b61012c610127366004611527565b61031f565b005b61012c61013c366004611569565b6103ce565b61015461014f366004611362565b610820565b6040516101109190611612565b6101887f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610110565b61012c6101ae366004611527565b610a64565b61012c6101c1366004611527565b610df1565b61021c6101d436600461150e565b6001602052600090815260409020546001600160a01b0381169061ffff600160a01b8204169060ff600160b01b8204811691600160b81b8104821691600160c01b9091041685565b604080516001600160a01b03909616865261ffff90941660208601529115159284019290925290151560608301521515608082015260a001610110565b6101887f000000000000000000000000000000000000000000000000000000000000000081565b6040805160a08101825260008082526020820181905291810182905260608101829052608081019190915250600090815260016020908152604091829020825160a08101845290546001600160a01b038116825261ffff600160a01b8204169282019290925260ff600160b01b83048116151593820193909352600160b81b8204831615156060820152600160c01b9091049091161515608082015290565b337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161461035457600080fd5b60009283526001602052604090922080547701010000000000000000000000000000000000000000000061ffff60b01b1961ffff909516600160a01b027fffffffffffffffffffff000000000000000000000000000000000000000000009092166001600160a01b03909416939093171792909216179055565b60006103d983610280565b604051633e8cf2cb60e11b8152600481018590529091506000906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690637d19e596906024016102006040518083038186803b15801561044057600080fd5b505afa158015610454573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104789190611405565b82519091506001600160a01b0316336001600160a01b0316146104e25760405162461bcd60e51b815260206004820152600560248201527f322d30303500000000000000000000000000000000000000000000000000000060448201526064015b60405180910390fd5b816060015180156104f4575081604001515b6105405760405162461bcd60e51b815260206004820152600560248201527f322d30303100000000000000000000000000000000000000000000000000000060448201526064016104d9565b61055060408401602085016114ea565b61055d60208501856114ea565b61056791906117f1565b61ffff16612710146105bb5760405162461bcd60e51b815260206004820152600560248201527f312d30303700000000000000000000000000000000000000000000000000000060448201526064016104d9565b6101208101516105d29060005b6020020151611104565b6105dd9060016117ac565b61012082018051600192830b830b9052516105f7916105c8565b610120820151600191820b90910b602091820152610617908401846114ea565b61014082015161ffff91909116905261063660408401602085016114ea565b6101408201805161ffff92909216602090920191909152516101208201516040517f64166e630000000000000000000000000000000000000000000000000000000081527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316926364166e63926106bb9289929190600401611761565b600060405180830381600087803b1580156106d557600080fd5b505af11580156106e9573d6000803e3d6000fd5b50505060008581526001602052604080822080547fffffffffffffff00ffffffffffffffffffffffffffffffffffffffffffffffff16600160c01b179055517f379607f5000000000000000000000000000000000000000000000000000000008152600481018790529091506001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063379607f59060240160a060405180830381600087803b1580156107a357600080fd5b505af11580156107b7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107db919061138a565b9050847f078c1bd0728767e70d5913396262af1d8c75f3daa7a80c3c6af9594909bf806383428460405161081193929190611647565b60405180910390a25050505050565b610828611208565b610830611208565b6000808061084460a08701608088016114ea565b61ffff1611156108e15761271061085e60208701876114ea565b61ffff1661087260a08801608089016114ea565b61ffff166108809190611851565b61088a919061182f565b905061271061089f60408701602088016114ea565b61ffff166108b360a08801608089016114ea565b61ffff166108c19190611851565b6108cb919061182f565b91506108d782826117f1565b61ffff1660808401525b60006108f360808701606088016114ea565b61ffff1611156109465761271061091060408701602088016114ea565b61ffff1661092460808801606089016114ea565b61ffff166109329190611851565b61093c919061182f565b61ffff1660608401525b600061095860608701604088016114ea565b61ffff1611156109ab5761271061097560408701602088016114ea565b61ffff1661098960608801604089016114ea565b61ffff166109979190611851565b6109a1919061182f565b61ffff1660408401525b60006109ba60208701876114ea565b61ffff1611156109eb5761ffff81166109d660208701876114ea565b61ffff166109e49190611870565b61ffff1683525b60006109fd60408701602088016114ea565b61ffff161115610a5b57604080840151606085015161ffff8581169392811692911690610a2f90890160208a016114ea565b61ffff16610a3d9190611870565b610a479190611870565b610a519190611870565b61ffff1660208401525b50909392505050565b8233610a708282611127565b610aa45760405162461bcd60e51b81526020600482015260056024820152640c8b4c0c0d60da1b60448201526064016104d9565b6000858152600160205260408082209051633e8cf2cb60e11b8152600481018890529091907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690637d19e596906024016102006040518083038186803b158015610b1657600080fd5b505afa158015610b2a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b4e9190611405565b90506001600160a01b038616610ba65760405162461bcd60e51b815260206004820152600560248201527f322d30303900000000000000000000000000000000000000000000000000000060448201526064016104d9565b80516001600160a01b03878116911614801590610bd9575080604001516001600160a01b0316866001600160a01b031614155b610c255760405162461bcd60e51b815260206004820152600560248201527f322d30313000000000000000000000000000000000000000000000000000000060448201526064016104d9565b8154600160b81b900460ff161580610c4657508154600160b01b900460ff16155b610c925760405162461bcd60e51b815260206004820152600560248201527f322d30303600000000000000000000000000000000000000000000000000000060448201526064016104d9565b6101408101516127109061ffff8716906003602002015161ffff168360a00151610cbc9190611817565b610cc69190611817565b10610cfb5760405162461bcd60e51b8152602060048201526005602482015264322d30303760d81b60448201526064016104d9565b81546001600160a01b0387167fffffffffffffffffffff0000000000000000000000000000000000000000000090911617600160a01b61ffff871602178255610d52813390516001600160a01b0390811691161490565b15610d6e57815461ffff60b01b1916600160b81b178255610d96565b60408101516001600160a01b0316331415610d9657815461ffff60b01b1916600160b01b1782555b604080516001600160a01b038816815261ffff87166020820152339181019190915287907fbf42827f17777ed92b098fa9e5f6823ecb5c116e3b23909cc242530b1784dbbc906060015b60405180910390a250505050505050565b8233610dfd8282611127565b610e315760405162461bcd60e51b81526020600482015260056024820152640c8b4c0c0d60da1b60448201526064016104d9565b6000610e3c86610280565b604051633e8cf2cb60e11b8152600481018890529091506000906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690637d19e596906024016102006040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190611405565b82519091506001600160a01b0316610f1d5760405162461bcd60e51b81526020600482015260056024820152640645a6060760db1b60448201526064016104d9565b81516001600160a01b03878116911614610f615760405162461bcd60e51b81526020600482015260056024820152640645a6060760db1b60448201526064016104d9565b816020015161ffff168561ffff1614610fa45760405162461bcd60e51b8152602060048201526005602482015264322d30303760d81b60448201526064016104d9565b80516001600160a01b031633141561102b57606082015115610ff05760405162461bcd60e51b8152602060048201526005602482015264322d30303360d81b60448201526064016104d9565b600087815260016020526040902080547fffffffffffffffff00ffffffffffffffffffffffffffffffffffffffffffffff16600160b81b1790555b60408101516001600160a01b03163314156110b55760408201511561107a5760405162461bcd60e51b8152602060048201526005602482015264322d30303360d81b60448201526064016104d9565b600087815260016020526040902080547fffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffffffff16600160b01b1790555b8151602083015160405189927fd514ca74d69a194b5d9455914d0d20ef96d29b6177b241c9d5f608264055199c92610de0926001600160a01b0392909216825261ffff16602082015260400190565b6000808260010b121561111f5761111a82611887565b611121565b815b92915050565b604051633e8cf2cb60e11b81526004810183905260009081906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690637d19e596906024016102006040518083038186803b15801561118d57600080fd5b505afa1580156111a1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111c59190611405565b9050826001600160a01b031681600001516001600160a01b031614806112005750826001600160a01b031681604001516001600160a01b0316145b949350505050565b6040518060a001604052806005906020820280368337509192915050565b8051611231816118d5565b919050565b600082601f83011261124757600080fd5b6040516040810181811067ffffffffffffffff8211171561126a5761126a6118bf565b806040525080838560408601111561128157600080fd5b6000805b60028110156112b35782518060010b811461129e578283fd5b84526020938401939290920191600101611285565b50929695505050505050565b600082601f8301126112d057600080fd5b6040516080810181811067ffffffffffffffff821117156112f3576112f36118bf565b60405280836080810186101561130857600080fd5b60005b600481101561133457815161131f816118ed565b8352602092830192919091019060010161130b565b509195945050505050565b8051611231816118ed565b805167ffffffffffffffff8116811461123157600080fd5b600060a0828403121561137457600080fd5b8260a08301111561138457600080fd5b50919050565b600060a0828403121561139c57600080fd5b82601f8301126113ab57600080fd5b60405160a0810181811067ffffffffffffffff821117156113ce576113ce6118bf565b604052808360a081018610156113e357600080fd5b60005b60058110156113345781518352602092830192909101906001016113e6565b6000610200828403121561141857600080fd5b611420611782565b61142983611226565b81526114376020840161134a565b602082015261144860408401611226565b60408201526114596060840161134a565b606082015261146a60808401611226565b608082015260a083015160a082015261148560c0840161134a565b60c082015261149660e08401611226565b60e08201526101006114a981850161133f565b908201526101206114bc85858301611236565b908201526101606114cf858583016112bf565b6101408301526101e084015181830152508091505092915050565b6000602082840312156114fc57600080fd5b8135611507816118ed565b9392505050565b60006020828403121561152057600080fd5b5035919050565b60008060006060848603121561153c57600080fd5b83359250602084013561154e816118d5565b9150604084013561155e816118ed565b809150509250925092565b6000806060838503121561157c57600080fd5b823591508360608401111561159057600080fd5b50926020919091019150565b8060005b60028110156115c2578151600190810b855260209485019490920191016115a0565b50505050565b8060005b60048110156115c257815161ffff168452602093840193909101906001016115cc565b8060005b60058110156115c25781518452602093840193909101906001016115f3565b60a08101818360005b600581101561163e57815161ffff1683526020928301929091019060010161161b565b50505092915050565b83516001600160a01b031681526102c081016020850151611674602084018267ffffffffffffffff169052565b50604085015161168f60408401826001600160a01b03169052565b5060608501516116ab606084018267ffffffffffffffff169052565b5060808501516116c660808401826001600160a01b03169052565b5060a085015160a083015260c08501516116ec60c084018267ffffffffffffffff169052565b5060e085015161170760e08401826001600160a01b03169052565b506101008581015161ffff16908301526101208086015161172a8285018261159c565b5050610140850151610160611741818501836115c8565b8601516101e08401525061020082018490526112006102208301846115ef565b83815260e0810161177560208301856115c8565b61120060a083018461159c565b604051610180810167ffffffffffffffff811182821017156117a6576117a66118bf565b60405290565b60008160010b8360010b6000821282617fff038213811516156117d1576117d16118a9565b82617fff190382128116156117e8576117e86118a9565b50019392505050565b600061ffff80831681851680830382111561180e5761180e6118a9565b01949350505050565b6000821982111561182a5761182a6118a9565b500190565b60008261184c57634e487b7160e01b600052601260045260246000fd5b500490565b600081600019048311821515161561186b5761186b6118a9565b500290565b600082821015611882576118826118a9565b500390565b60008160010b617fff198114156118a0576118a06118a9565b60000392915050565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b03811681146118ea57600080fd5b50565b61ffff811681146118ea57600080fdfea26469706673582212204c16672b65f7ada3cbf8a0d226af782f701748b77b23bf981ad80327f1fe910364736f6c6343000807003300000000000000000000000024e9ecc6c56dcd0c875fdf181fa3a4eef3c5d5f000000000000000000000000040f83551803051676eb7cb0374176d03db247b970000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000410000000000000000000000006aa0d0671828fb7a66e080f06f91b453a696c40f00000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000020000000000000000000000006aa0d0671828fb7a66e080f06f91b453a696c40f0000000000000000000000000000000000000000000000000000000000000001",
        "logIndex": 0,
        "blockHash": "0xa70d9e6d9cf39bba374cbf63d1b5e877c2942f26cb4df36f18442c1e0ea77749"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 51872239,
        "transactionHash": "0xc9aec406ca73e9da2b11e9a5d9cb80c745b46a6a1e059582696713cfc70c43c6",
        "address": "0x81161454A163EbbA69F153e6919D1f986bbBd791",
        "topics": [
          "0x4db17dd5e4732fb6da34a148104a592783ca119a1e7bb8829eba6cbadef0b511"
        ],
        "data": "0x000000000000000000000000f1447b0fda912a6857b5d77d7cde9663266896cf",
        "logIndex": 1,
        "blockHash": "0xa70d9e6d9cf39bba374cbf63d1b5e877c2942f26cb4df36f18442c1e0ea77749"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 51872239,
        "transactionHash": "0xc9aec406ca73e9da2b11e9a5d9cb80c745b46a6a1e059582696713cfc70c43c6",
        "address": "0x81161454A163EbbA69F153e6919D1f986bbBd791",
        "topics": [
          "0x442e715f626346e8c54381002da614f62bee8d27386535b2521ec8540898556e"
        ],
        "data": "0x49f87683f5b826355b5e041c56210c10352eb1863fea995af2009fc8bc4262cc0000000000000000000000000000000000000000000000000000000000000000",
        "logIndex": 2,
        "blockHash": "0xa70d9e6d9cf39bba374cbf63d1b5e877c2942f26cb4df36f18442c1e0ea77749"
      }
    ],
    "blockNumber": 51872239,
    "cumulativeGasUsed": "10175538",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x24e9ECC6c56dcD0C875fDF181FA3A4EEf3c5D5F0",
    "0x40F83551803051676eB7Cb0374176d03db247b97"
  ],
  "numDeployments": 2,
  "solcInputHash": "dd06e32b55195a1ed654e198c4426365",
  "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"unicrow_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"unicrowClaim_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"escrowId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"challengeExtension\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"challengePeriodStart\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"marketplaceFee\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"challengePeriodEnd\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"claimed\",\"type\":\"uint16\"},{\"internalType\":\"int16[2]\",\"name\":\"consensus\",\"type\":\"int16[2]\"},{\"internalType\":\"uint16[4]\",\"name\":\"split\",\"type\":\"uint16[4]\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Escrow\",\"name\":\"escrow\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[5]\",\"name\":\"amounts\",\"type\":\"uint256[5]\"}],\"name\":\"Arbitrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"escrowId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"arbitratorFee\",\"type\":\"uint256\"}],\"name\":\"ArbitratorApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"escrowId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"arbitratorFee\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"}],\"name\":\"ArbitratorProposed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"escrowId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"validationAddress\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"validation\",\"type\":\"uint16\"}],\"name\":\"approveArbitrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"escrowId\",\"type\":\"uint256\"},{\"internalType\":\"uint16[2]\",\"name\":\"newSplit\",\"type\":\"uint16[2]\"}],\"name\":\"arbitrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[5]\",\"name\":\"currentSplit\",\"type\":\"uint16[5]\"}],\"name\":\"arbitrationCalculation\",\"outputs\":[{\"internalType\":\"uint16[5]\",\"name\":\"\",\"type\":\"uint16[5]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"escrowArbitrator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"arbitratorFee\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"sellerConsensus\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"buyerConsensus\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"arbitrated\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"escrowId\",\"type\":\"uint256\"}],\"name\":\"getArbitratorData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"arbitratorFee\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"sellerConsensus\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"buyerConsensus\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"arbitrated\",\"type\":\"bool\"}],\"internalType\":\"struct Arbitrator\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"escrowId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"arbitratorFee\",\"type\":\"uint16\"}],\"name\":\"proposeArbitrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"escrowId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"arbitratorFee\",\"type\":\"uint16\"}],\"name\":\"setArbitrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unicrow\",\"outputs\":[{\"internalType\":\"contract Unicrow\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unicrowClaim\",\"outputs\":[{\"internalType\":\"contract IUnicrowClaim\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"Arbitrated(uint256,(address,uint64,address,uint64,address,uint256,uint64,address,uint16,int16[2],uint16[4],uint256),uint256,uint256[5])\":{\"details\":\"Emitted when the arbitrator has resolved a dispute\",\"params\":{\"amounts\":\"All amounts (i.e. incl. marketplace fee, arbitrator fee, and protocol fee) in the token\",\"blockTime\":\"Timestamp of the block in which the transaction was minuted\",\"escrow\":\"The escrow data, incl. the final split between buyer and seller as decided by the arbitrator\",\"escrowId\":\"Id of the arbitrated escrow\"}},\"ArbitratorApproved(uint256,address,uint256)\":{\"details\":\"Emitted when the arbitrator proposal was approved by the other party\",\"params\":{\"arbitrator\":\"Arbitrator's address\",\"arbitratorFee\":\"Proposed fee in bips\",\"escrowId\":\"Id of the escrow to which the proposer belongs\"}},\"ArbitratorProposed(uint256,address,uint16,address)\":{\"details\":\"Emitted when an arbitrator has been proposed by one of the parties orif the other party sends a different proposal or also if the original party changes their proposal\",\"params\":{\"arbitrator\":\"Arbitrator's address\",\"arbitratorFee\":\"Proposed fee in bips\",\"escrowId\":\"Id of the escrow to which the proposer belongs\",\"proposer\":\"Address of the party that sent the proposal\"}}},\"kind\":\"dev\",\"methods\":{\"approveArbitrator(uint256,address,uint16)\":{\"details\":\"To ensure the user approves an arbitrator they wanted, it requires the same parameters as proposal\",\"params\":{\"escrowId\":\"Id of an escrow\",\"validation\":\"Arbitrator's Fee - will be compared with the existing proposal\",\"validationAddress\":\"Arbitrator's address - will be compared with the existing proposal\"}},\"arbitrate(uint256,uint16[2])\":{\"params\":{\"escrowId\":\"Id of an escrow\",\"newSplit\":\"How the payment should be split between buyer [0] and seller [1]. [100, 0] will refund the payment to the buyer, [0, 100] will release it to the seller, anything in between will\"}},\"arbitrationCalculation(uint16[5])\":{\"details\":\"Calculates final splits of all parties involved in the payment when the paymet is decided by an arbitrator.If seller's split is < 100% it will discount the marketplace and protocol fee, but (unlike when refunded byseller or settled mutually) will keep full Arbitrator fee and deduct it from both shares proportionally\",\"params\":{\"currentSplit\":\"Current split in bips. See WHO_* contants for keys\"},\"returns\":{\"_0\":\"Splits in bips using the same keys for the array\"}},\"constructor\":{\"params\":{\"unicrowClaim_\":\"UnicrowClaim contract address\",\"unicrow_\":\"Unicrow contract address\"}},\"getArbitratorData(uint256)\":{\"details\":\"buyerConsensus and sellerConsensus indicate if the arbitrator was only proposed by one of the parties orhas been assigned by the mutual consensus\",\"params\":{\"escrowId\":\"ID of the escrow\"},\"returns\":{\"_0\":\"Arbitrator information.\"}},\"proposeArbitrator(uint256,address,uint16)\":{\"params\":{\"arbitrator\":\"Arbitrator's address\",\"arbitratorFee\":\"Arbitrator fee in bips (can be 0)\",\"escrowId\":\"Id of the escrow\"}},\"setArbitrator(uint256,address,uint16)\":{\"details\":\"Called by Unicrow.pay()\",\"params\":{\"arbitrator\":\"Arbitrator's address\",\"arbitratorFee\":\"Arbitrator fee in bips (can be 0)\",\"escrowId\":\"Id of the escrow\"}}},\"title\":\"Unicrow Arbitrator\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"approveArbitrator(uint256,address,uint16)\":{\"notice\":\"Approve an arbitrator proposed by another party (i.e. by seller if buyer proposed, by buyer if seller proposed).\"},\"arbitrate(uint256,uint16[2])\":{\"notice\":\"Arbitrate an payment - to be called only by an escrow's arbitrator\"},\"constructor\":{\"notice\":\"The constructor provides immutable reference to the main escrow and claimMultiple contracts\"},\"escrowArbitrator(uint256)\":{\"notice\":\"Stores information about arbitrators in relation to escrows\"},\"getArbitratorData(uint256)\":{\"notice\":\"Get information about proposed or assigned arbitrator.\"},\"proposeArbitrator(uint256,address,uint16)\":{\"notice\":\"One of the parties (buyer or seller) can call this to propose an arbitrator for an escrow that has no arbitrator defined\"},\"setArbitrator(uint256,address,uint16)\":{\"notice\":\"Assigns an arbitrator to an escrow.\"},\"unicrow()\":{\"notice\":\"Reference to the main Unicrow contract\"},\"unicrowClaim()\":{\"notice\":\"Reference to the contract that manages claims from the escrows\"}},\"notice\":\"Functionality for assigning an arbitrator to an escrow and for an arbitrator to decide a dispute\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/UnicrowArbitrator.sol\":\"UnicrowArbitrator\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/security/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x0e9621f60b2faabe65549f7ed0f24e8853a45c1b7990d47e8160e523683f3935\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0xe0c8b625a79bac0fe80f17cfb521e072805cc9cef1c96a5caf45b264e74812fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc3d946432c0ddbb1f846a0d3985be71299df331b91d06732152117f62f0be2b5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ccf9d2313a313d41a791505f2b5abfdc62191b5d4334f7f7a82691c088a1c87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Counters.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\",\"keccak256\":\"0xf0018c2440fbe238dd3a8732fa8e17a0f9dce84d31451dc8a32f6d62b349c9f1\",\"license\":\"MIT\"},\"contracts/Unicrow.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./interfaces/IUnicrow.sol\\\";\\nimport \\\"./interfaces/IUnicrowClaim.sol\\\";\\nimport \\\"./interfaces/IUnicrowArbitrator.sol\\\";\\nimport \\\"./UnicrowDispute.sol\\\";\\nimport \\\"./UnicrowTypes.sol\\\";\\n\\n/// @title The primary Unicrow contract\\n/// @notice Receives and distributes the payments, maintains and provides information about the escrow records, and allows basic operations\\ncontract Unicrow is ReentrancyGuard, IUnicrow, Context {\\n    using Counters for Counters.Counter;\\n\\n    /// Generates unique escrow ID in incremental order\\n    Counters.Counter public escrowIdCounter;\\n\\n    /// @notice Arbitrator information and functionality for the escrows\\n    IUnicrowArbitrator public immutable unicrowArbitrator;\\n\\n    /// @notice Withdraws payments from the escrows once the criteria are met\\n    IUnicrowClaim public immutable unicrowClaim;\\n\\n    /// @notice Dispute resolution, incl. challenges and settlements\\n    UnicrowDispute public immutable unicrowDispute;\\n\\n    /// @notice Escrow fee in bips (can never be higher than 100)\\n    uint16 public protocolFee;\\n\\n    /// address of a governance contract (multisig initially, DAO governor eventually)\\n    address public governanceAddress;\\n\\n    /// storage of the primary escrow data. The key is generated by the contract incrementally\\n    mapping(uint256 => Escrow) escrows;\\n\\n    /**\\n     * @notice Emitted when the payment is deposited into the contract and an escrow record is created\\n     * @param escrowId Unique, contract-generated escrow record identifier\\n     * @param blockTime timestamp of the block in which the transaction was included\\n     * @param escrow Details of the escrow as stored in the contract\\n     * @param arbitrator Address of an arbitrator (zero is returned if no arbitrator was defined)\\n     * @param arbitratorFee Arbitrator's fee in bips\\n     * @param challengePeriod Initial challenge period in seconds\\n     */\\n    event Pay(uint256 indexed escrowId, uint256 blockTime, Escrow escrow, address arbitrator, uint256 arbitratorFee, uint256 challengePeriod);\\n\\n    /**\\n     * @notice Emitted when the buyer releases the payment manually (regardless of the challenge period)\\n     * @param escrowId ID of the released escrow payment\\n     * @param blockTime Timestamp of the block in which the transaction was included\\n     * @param escrow Details of the released Escrow\\n     * @param amounts Amounts in token allocated to each party (incl. fees). See UnicrowTypes for mapping of each party (WHO_*)\\n     */\\n    event Release(uint256 indexed escrowId, uint256 blockTime, Escrow escrow, uint256[5] amounts);\\n\\n    /**\\n     * @notice Emitted when seller fully refunds the payment. Detailed calculated values are not returned because the payment is refunded in full, all fees are waived\\n     * @param escrowId Id of the refunded payment\\n     * @param escrow Details of the refunded payment\\n     * @param blockTime Timestamp of the block in which the transaction was included\\n     */\\n    event Refund(uint256 indexed escrowId, Escrow escrow, uint256 blockTime);\\n\\n    /// The contructor initiates immutable and governed references to other contracts\\n    constructor(\\n        address unicrowClaim_,\\n        address unicrowArbitrator_,\\n        address unicrowDispute_,\\n        address governanceAddress_,\\n        uint16 protocolFee_\\n    ) {\\n        unicrowArbitrator = IUnicrowArbitrator(unicrowArbitrator_);\\n        unicrowClaim = IUnicrowClaim(unicrowClaim_);\\n        unicrowDispute = UnicrowDispute(unicrowDispute_);\\n        governanceAddress = governanceAddress_;\\n        protocolFee = protocolFee_;\\n    }\\n\\n    /// Check that the governance contract is calling this\\n    modifier onlyGovernance() {\\n        require(_msgSender() == governanceAddress);\\n        _;\\n    }\\n\\n    /// Check that Unicrow's claimMultiple contract is calling this\\n    modifier onlyUnicrowClaim() {\\n        require(_msgSender() == address(unicrowClaim));\\n        _;\\n    }\\n\\n    /// Check that arbitration or dispute contract is calling this\\n    modifier onlyUnicrowArbitratorOrDispute() {\\n        require(_msgSender() == address(unicrowArbitrator) || _msgSender() == address(unicrowDispute));\\n        _;\\n    }\\n\\n    /// Check that dispute contract is calling this\\n    modifier onlyUnicrowDispute() {\\n        require(_msgSender() == address(unicrowDispute));\\n        _;\\n    }\\n\\n    /// @inheritdoc IUnicrow\\n    function pay(\\n        EscrowInput calldata input,\\n        address arbitrator,\\n        uint16 arbitratorFee\\n    ) external override payable nonReentrant {\\n        // Get current escrow id from the incremental counter\\n        uint256 escrowId = escrowIdCounter.current();\\n\\n        // The address that sent the payment is set as a buyer\\n        address buyer = _msgSender();\\n\\n        // Amount of the payment in ERC20 tokens\\n        uint amount = input.amount;\\n\\n        // Make sure there's something left for the seller :-)\\n        require(arbitratorFee + input.marketplaceFee + protocolFee < 10000, \\\"1-026\\\");\\n\\n        // Payment can't use address(0)\\n        require(escrows[escrowId].buyer == address(0), \\\"0-001\\\");\\n\\n        // Seller cannot be empty\\n        require(input.seller != address(0), \\\"0-002\\\");\\n\\n        // Buyer cannot be seller\\n        require(buyer != input.seller, \\\"0-003\\\");\\n\\n        // Payment amount must be greater than zero\\n        require(amount > 0, \\\"0-011\\\");\\n\\n        // Buyer can't send ETH if currency is not ETH\\n        if(msg.value > 0) {\\n            require(input.currency == address(0), \\\"0-010\\\");\\n        }\\n        \\n        // Check if the payment was made in ETH \\n        if (input.currency == address(0)) {\\n            // Amount in the payment metadata must match what was sent\\n            require(amount == msg.value);\\n        } else {\\n            uint balanceBefore = IERC20(input.currency).balanceOf(address(this));\\n\\n            // If the payment was made in ERC20 and not ETH, execute the transfer\\n            SafeERC20.safeTransferFrom(\\n                IERC20(input.currency),\\n                buyer,\\n                address(this),\\n                amount\\n            );\\n\\n            uint balanceAfter = IERC20(input.currency).balanceOf(address(this));\\n\\n            // Make sure that the input amount is the amount received\\n            amount = balanceAfter - balanceBefore;\\n        }\\n\\n        // If a marketplace fee was set, ensure a marketplace address was set\\n        if(input.marketplaceFee > 0) {\\n            require(input.marketplace != address(0), \\\"0-009\\\");\\n        }\\n\\n        // Check if the arbitrator was defined\\n        if (arbitrator != address(0)) {\\n\\n            // Arbitrator can't be seller or buyer\\n            require(arbitrator != buyer && arbitrator != input.seller, \\\"1-027\\\");\\n\\n            // Set the arbitrator in the arbitrator contract\\n            unicrowArbitrator.setArbitrator(escrowId, arbitrator, arbitratorFee);\\n        }\\n\\n        // Split array is how Unicrow maintains information about seller's and buyer's shares, and the fees\\n        uint16[4] memory split = [0, 10000, input.marketplaceFee, protocolFee];\\n        \\n        // Set initial consensus to buyer = 0, seller = 1\\n        int16[2] memory consensus = [int16(0), int16(1)];\\n\\n        // Create an Escrow object that will be stored in the contract\\n        Escrow memory escrow = Escrow({\\n            buyer: buyer,\\n            seller: input.seller,\\n            currency: input.currency,\\n            marketplace: input.marketplace,\\n            marketplaceFee: input.marketplaceFee,\\n            claimed: 0,\\n            split: split,\\n            consensus: consensus,\\n            challengeExtension: uint64(input.challengeExtension > 0 ? input.challengeExtension : input.challengePeriod),\\n            challengePeriodStart: uint64(block.timestamp), //challenge start\\n            challengePeriodEnd: uint64(block.timestamp + input.challengePeriod), //chalenge end\\n            amount: amount\\n        });\\n\\n        // Store the escrow information\\n        escrows[escrowId] = escrow;\\n\\n        // Increase the escrow id counter\\n        escrowIdCounter.increment();\\n\\n        emit Pay(escrowId, block.timestamp, escrow, arbitrator, arbitratorFee, input.challengePeriod);\\n    }\\n\\n    /// @inheritdoc IUnicrow\\n    function refund(uint256 escrowId) external override nonReentrant {\\n        address sender = _msgSender();\\n\\n        // Get escrow information from the contract's storage\\n        Escrow memory escrow = escrows[escrowId];\\n\\n        // Only seller can refund\\n        require(sender == escrow.seller, \\\"1-011\\\");\\n\\n        // Check that the escrow is not claimed yet\\n        require(escrow.claimed == 0, \\\"0-005\\\");\\n\\n        // Set split to 100% to buyer and waive the fees\\n        escrow.split[WHO_BUYER] = 10000;\\n        escrow.split[WHO_SELLER] = 0;\\n        escrow.split[WHO_MARKETPLACE] = 0;\\n        escrow.split[WHO_PROTOCOL] = 0;\\n        \\n        // Keep record of number of challenges (for reputation purposes)\\n        escrow.consensus[WHO_BUYER] = abs8(escrow.consensus[WHO_BUYER]) + 1;\\n\\n        // Set escrow consensus based on the number of previous challenges (1 = no challenge)\\n        escrow.consensus[WHO_SELLER] = abs8(escrow.consensus[WHO_SELLER]);\\n\\n        // Update splits and consensus information in the storage\\n        escrows[escrowId].split = escrow.split;\\n        escrows[escrowId].consensus = escrow.consensus;\\n\\n        // Update the escrow as claimed in the storage and in the emitted event\\n        escrows[escrowId].claimed = 1;\\n        escrow.claimed = 1;\\n\\n        // Withdraw the amount to the buyer\\n        if (address(escrow.currency) == address(0)) {\\n            (bool success, ) = escrow.buyer.call{value: escrow.amount}(\\\"\\\");\\n            require(success, \\\"1-012\\\");\\n        } else {\\n            SafeERC20.safeTransfer(\\n                IERC20(escrow.currency),\\n                escrow.buyer,\\n                escrow.amount\\n            );\\n        }\\n\\n\\n        emit Refund(escrowId, escrow, block.timestamp);\\n    }\\n\\n    /// @inheritdoc IUnicrow\\n    function release(uint256 escrowId) external override {\\n        address sender = _msgSender();\\n        Escrow memory escrow = escrows[escrowId];\\n\\n        // Only buyer can release\\n        require(sender == escrow.buyer, \\\"1-025\\\");\\n\\n        // Set buyer consensus to 1 or based on the number of previous challenges\\n        escrow.consensus[WHO_BUYER] = abs8(escrow.consensus[WHO_BUYER]) + 1;\\n\\n        // Set seller's escrow consensus based on the number of previous challenges\\n        escrow.consensus[WHO_SELLER] = abs8(escrow.consensus[WHO_SELLER]);\\n\\n        // Update consensus in the storage\\n        escrows[escrowId].consensus = escrow.consensus;\\n\\n        // Claim the payment and fees and get the final amounts\\n        uint256[5] memory amounts = unicrowClaim.claim(escrowId);\\n\\n        // Emit all the information including the amounts\\n        emit Release(escrowId, block.timestamp, escrow, amounts);\\n    }\\n\\n    /// @inheritdoc IUnicrow\\n    function challenge(\\n        uint256 escrowId,\\n        uint16[4] calldata split,\\n        int16[2] calldata consensus,\\n        uint64 challengeStart,\\n        uint64 challengeEnd\\n    ) external override onlyUnicrowDispute {\\n        escrows[escrowId].split = split;\\n        escrows[escrowId].consensus = consensus;\\n        escrows[escrowId].challengePeriodStart = challengeStart;\\n        escrows[escrowId].challengePeriodEnd = challengeEnd;\\n    }\\n\\n    /// @inheritdoc IUnicrow\\n    function updateEscrowFee(uint16 fee) external override onlyGovernance {\\n        require(fee <= 100, \\\"0-008\\\");\\n        protocolFee = fee;\\n    }\\n\\n    /// @inheritdoc IUnicrow\\n    function updateGovernance(address governance) external override onlyGovernance {\\n        governanceAddress = governance;\\n    }\\n\\n    /// @notice Return basic escrow information (excl. arbitration information, settlement offers, and token details)\\n    /// @param escrowId ID of the escrow to be returned\\n    function getEscrow(uint256 escrowId)\\n        external\\n        override\\n        view\\n        returns (Escrow memory)\\n    {\\n        return escrows[escrowId];\\n    }\\n\\n    /// @notice Return all the escrow data (incl. arbitration information, settlement offers, and token details)\\n    /// @param escrowId ID of the escrow to be returned\\n    function getAllEscrowData(uint256 escrowId)\\n        external\\n        view\\n        returns (Data memory)\\n    {\\n        address currency = escrows[escrowId].currency;\\n\\n        // Get information about the ERC20 token (or return ETH)\\n        Token memory token = Token({\\n            address_: currency,\\n            decimals: currency == address(0) ? 18 : ERC20(currency).decimals(),\\n            symbol: currency == address(0) ? \\\"ETH\\\" : ERC20(currency).symbol()\\n        });\\n\\n        Arbitrator memory arbitrator = unicrowArbitrator.getArbitratorData(escrowId);\\n        Settlement memory settlement = unicrowDispute.getSettlementDetails(escrowId);\\n\\n        return Data(\\n            escrows[escrowId],\\n            arbitrator,\\n            settlement,\\n            token\\n        );\\n    }\\n\\n    /// @dev Transfer ether or token from this contract's treasury. Can be called only by Unicrow's Claim contract\\n    function sendEscrowShare(\\n        address to,\\n        uint256 amount,\\n        address currency\\n    ) public onlyUnicrowClaim {\\n         if(currency == address(0)) {\\n            to.call{value: amount, gas: 5000}(\\\"\\\");\\n         } else {\\n           SafeERC20.safeTransfer(\\n                IERC20(currency),\\n                to,\\n                amount\\n            );\\n         }\\n     }\\n\\n    /// @inheritdoc IUnicrow\\n    function settle(\\n        uint256 escrowId,\\n        uint16[4] calldata split,\\n        int16[2] calldata consensus\\n    ) external override onlyUnicrowArbitratorOrDispute {\\n        escrows[escrowId].split = split;\\n        escrows[escrowId].consensus = consensus;\\n    }\\n\\n    /// @inheritdoc IUnicrow\\n    function splitCalculation(\\n        uint16[5] calldata currentSplit\\n    ) external pure override returns (uint16[5] memory) {\\n        uint16[5] memory split;\\n\\n        uint16 calculatedArbitratorFee;\\n\\n        // Discount the protocol fee based on seller's share\\n        if (currentSplit[WHO_PROTOCOL] > 0) {\\n            split[WHO_PROTOCOL] = uint16((\\n                uint256(currentSplit[WHO_PROTOCOL]) *\\n                    currentSplit[WHO_SELLER]) /\\n                    _100_PCT_IN_BIPS\\n            );\\n        }\\n\\n        // Discount the marketplace fee based on the seller's share\\n        if (currentSplit[WHO_MARKETPLACE] > 0) {\\n            split[WHO_MARKETPLACE] = uint16(\\n                (uint256(currentSplit[WHO_MARKETPLACE]) *\\n                    currentSplit[WHO_SELLER]) /\\n                    _100_PCT_IN_BIPS\\n            );\\n        }\\n\\n        // Calculate the arbitrator fee based on the seller's split\\n        if (currentSplit[WHO_ARBITRATOR] > 0) {\\n            calculatedArbitratorFee = uint16(\\n                (uint256(currentSplit[WHO_ARBITRATOR]) *\\n                    currentSplit[WHO_SELLER]) /\\n                    _100_PCT_IN_BIPS\\n            );\\n        }\\n\\n        // Calculate seller's final share by substracting all the fees\\n        split[WHO_SELLER] = currentSplit[WHO_SELLER] - split[WHO_PROTOCOL] - split[WHO_MARKETPLACE] - calculatedArbitratorFee;\\n        split[WHO_BUYER] = currentSplit[WHO_BUYER];\\n        split[WHO_ARBITRATOR] = calculatedArbitratorFee;\\n\\n        return split;\\n    }\\n\\n    /// @inheritdoc IUnicrow\\n    function setClaimed(uint256 escrowId) external override onlyUnicrowClaim nonReentrant {\\n        escrows[escrowId].claimed = 1;\\n    }\\n}\\n\",\"keccak256\":\"0x7fe4360efcdcb2930d20039f042eaee6b6b980ffca41a8b1eec75b6cb02f1f92\",\"license\":\"MIT\"},\"contracts/UnicrowArbitrator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"./Unicrow.sol\\\";\\nimport \\\"./interfaces/IUnicrowArbitrator.sol\\\";\\nimport \\\"./interfaces/IUnicrowClaim.sol\\\";\\nimport \\\"./UnicrowTypes.sol\\\";\\n\\n/**\\n * @title Unicrow Arbitrator\\n * @notice Functionality for assigning an arbitrator to an escrow and for an arbitrator to decide a dispute\\n */\\ncontract UnicrowArbitrator is IUnicrowArbitrator, Context, ReentrancyGuard {\\n    using Address for address payable;\\n\\n    /// Reference to the main Unicrow contract\\n    Unicrow public immutable unicrow;\\n    \\n    /// Reference to the contract that manages claims from the escrows\\n    IUnicrowClaim public immutable unicrowClaim;\\n\\n    /// Stores information about arbitrators in relation to escrows\\n    mapping(uint256 => Arbitrator) public escrowArbitrator;\\n\\n    /**\\n     * @dev Emitted when an arbitrator has been proposed by one of the parties or\\n     * @dev if the other party sends a different proposal or also if the original party changes their proposal\\n     * @param escrowId Id of the escrow to which the proposer belongs\\n     * @param arbitrator Arbitrator's address\\n     * @param arbitratorFee Proposed fee in bips\\n     * @param proposer Address of the party that sent the proposal\\n    */\\n    event ArbitratorProposed(uint256 indexed escrowId, address arbitrator, uint16 arbitratorFee, address proposer);\\n\\n    /**\\n     * @dev Emitted when the arbitrator proposal was approved by the other party\\n     * @param escrowId Id of the escrow to which the proposer belongs\\n     * @param arbitrator Arbitrator's address\\n     * @param arbitratorFee Proposed fee in bips\\n    */\\n    event ArbitratorApproved(uint256 indexed escrowId, address arbitrator, uint256 arbitratorFee);\\n\\n    /**\\n     * @dev Emitted when the arbitrator has resolved a dispute\\n     * @param escrowId Id of the arbitrated escrow\\n     * @param escrow The escrow data, incl. the final split between buyer and seller as decided by the arbitrator\\n     * @param blockTime Timestamp of the block in which the transaction was minuted\\n     * @param amounts All amounts (i.e. incl. marketplace fee, arbitrator fee, and protocol fee) in the token\\n     */\\n    event Arbitrated(uint256 indexed escrowId, Escrow escrow, uint256 blockTime, uint256[5] amounts);\\n\\n    /**\\n     * The constructor provides immutable reference to the main escrow and claimMultiple contracts\\n     * @param unicrow_ Unicrow contract address\\n     * @param unicrowClaim_ UnicrowClaim contract address\\n     */\\n    constructor(\\n        address unicrow_,\\n        address unicrowClaim_\\n    ) {\\n        unicrow = Unicrow(payable(unicrow_));\\n        unicrowClaim = IUnicrowClaim(payable(unicrowClaim_));\\n    }\\n\\n    /**\\n     * @dev Checks if the provided address is either a buyer or a seller in the provided escrow\\n     * @param escrowId Id of the escrow to check\\n     * @param caller Address to check against\\n     */\\n    modifier onlyEscrowMember(uint256 escrowId, address caller) {\\n        require(_isEscrowMember(escrowId, caller), \\\"2-004\\\");\\n        _;\\n    }\\n\\n    /// @dev Checks if the caller is the Unicrow's main escrow contract\\n    modifier onlyUnicrow() {\\n        require(_msgSender() == address(unicrow));\\n        _;\\n    }\\n\\n    /// @inheritdoc IUnicrowArbitrator\\n    function setArbitrator(\\n        uint256 escrowId,\\n        address arbitrator,\\n        uint16 arbitratorFee\\n    ) external override onlyUnicrow {\\n        // Store arbitrator address and fee\\n        escrowArbitrator[escrowId].arbitrator = arbitrator;\\n        escrowArbitrator[escrowId].arbitratorFee = arbitratorFee;\\n\\n        // In this case, the arbitrator was set during the payment,\\n        // so it is considered to be based on the mutual consensus consensus\\n        escrowArbitrator[escrowId].buyerConsensus = true;\\n        escrowArbitrator[escrowId].sellerConsensus = true;\\n    }\\n\\n    /// @inheritdoc IUnicrowArbitrator\\n    function proposeArbitrator(\\n        uint256 escrowId,\\n        address arbitrator,\\n        uint16 arbitratorFee\\n    ) external override onlyEscrowMember(escrowId, _msgSender()) {\\n        Arbitrator storage arbitratorData = escrowArbitrator[escrowId];\\n        Escrow memory escrow = unicrow.getEscrow(escrowId);\\n\\n        // Arbitrator can't be address 0\\n        require(arbitrator != address(0), \\\"2-009\\\");\\n\\n        // Check if arbitrator is not the buyer or seller\\n        require(arbitrator != escrow.buyer && arbitrator != escrow.seller, \\\"2-010\\\");\\n\\n        // Check that arbitrator hasnt't been set already\\n        require(!arbitratorData.buyerConsensus || !arbitratorData.sellerConsensus,\\\"2-006\\\" );\\n\\n        // Make sure there's something left for the seller :-)\\n        require(escrow.marketplaceFee + escrow.split[WHO_PROTOCOL] + arbitratorFee < 10000, \\\"2-007\\\");\\n\\n        // Save the proposal parameters\\n        arbitratorData.arbitrator = arbitrator;\\n        arbitratorData.arbitratorFee = arbitratorFee;\\n\\n        // That the arbitrator is only proposed and not assigne is indicated by a lack of consensus\\n        if (_isEscrowBuyer(escrow, _msgSender())) {\\n            arbitratorData.buyerConsensus = true;\\n            arbitratorData.sellerConsensus = false;\\n        } else if (_isEscrowSeller(escrow, _msgSender())) {\\n            arbitratorData.sellerConsensus = true;\\n            arbitratorData.buyerConsensus = false;\\n        }\\n\\n        emit ArbitratorProposed(\\n            escrowId,\\n            arbitrator,\\n            arbitratorFee,\\n            _msgSender()\\n        );\\n    }\\n\\n    /// @inheritdoc IUnicrowArbitrator\\n    function approveArbitrator(uint256 escrowId, address validationAddress, uint16 validation)\\n        external\\n        override\\n        onlyEscrowMember(escrowId, _msgSender())\\n    {\\n        Arbitrator memory arbitratorData = getArbitratorData(escrowId);\\n        Escrow memory escrow = unicrow.getEscrow(escrowId);\\n\\n        // Check that the arbitrator has been proposed\\n        require(arbitratorData.arbitrator != address(0), \\\"2-008\\\");\\n\\n        // Compare the approval to the original proposal\\n        require(validationAddress == arbitratorData.arbitrator, \\\"2-008\\\");\\n        require(validation == arbitratorData.arbitratorFee, \\\"2-007\\\");\\n\\n        // Check that the buyer is approving seller's proposal (or vice versa) and if yes, confirm the consensus\\n        if (_isEscrowBuyer(escrow, _msgSender())) {\\n            require(\\n                arbitratorData.buyerConsensus == false,\\n                \\\"2-003\\\"\\n            );\\n            escrowArbitrator[escrowId].buyerConsensus = true;\\n        }\\n        if (_isEscrowSeller(escrow, _msgSender())) {\\n            require(\\n                arbitratorData.sellerConsensus == false,\\n                \\\"2-003\\\"\\n            );\\n            escrowArbitrator[escrowId].sellerConsensus = true;\\n        }\\n\\n        emit ArbitratorApproved(escrowId, arbitratorData.arbitrator, arbitratorData.arbitratorFee);\\n    }\\n\\n    /// @inheritdoc IUnicrowArbitrator\\n    function arbitrate(uint256 escrowId, uint16[2] calldata newSplit)\\n        external\\n        override\\n    {\\n        Arbitrator memory arbitratorData = getArbitratorData(escrowId);\\n        Escrow memory escrow = unicrow.getEscrow(escrowId);\\n\\n        // Check that this is this escrow's arbitrator calling\\n        require(_msgSender() == arbitratorData.arbitrator, \\\"2-005\\\");\\n        \\n        // Check that the arbitrator was set by mutual consensus\\n        require(\\n            arbitratorData.buyerConsensus && arbitratorData.sellerConsensus,\\n            \\\"2-001\\\"\\n        );\\n        \\n        // Ensure the splits equal 100%\\n        require(newSplit[WHO_BUYER] + newSplit[WHO_SELLER] == 10000, \\\"1-007\\\");\\n\\n        // Retain number of challenges in the final consensus record\\n        escrow.consensus[WHO_BUYER] = abs8(escrow.consensus[WHO_BUYER]) + 1;\\n        escrow.consensus[WHO_SELLER] = abs8(escrow.consensus[WHO_SELLER]);\\n\\n        // Update gross (pre-fees) splits as defined in the arbitration\\n        escrow.split[WHO_BUYER] = newSplit[WHO_BUYER];\\n        escrow.split[WHO_SELLER] = newSplit[WHO_SELLER];\\n\\n        // Execute settlement on the escrow\\n        unicrow.settle(\\n            escrowId,\\n            escrow.split,\\n            escrow.consensus\\n        );\\n\\n        // Set the payment as arbitrated\\n        escrowArbitrator[escrowId].arbitrated = true;\\n\\n        // Withdraw the amounts accordingly\\n        //   (this will take into account that arbitrator called this and will set arbitrator fee accordingly)\\n        uint256[5] memory amounts = unicrowClaim.claim(escrowId);\\n\\n        emit Arbitrated(escrowId, escrow, block.timestamp, amounts);\\n    }\\n\\n    /**\\n     * @dev Calculates final splits of all parties involved in the payment when the paymet is decided by an arbitrator.\\n     * @dev If seller's split is < 100% it will discount the marketplace and protocol fee, but (unlike when refunded by\\n     * @dev seller or settled mutually) will keep full Arbitrator fee and deduct it from both shares proportionally\\n     * @param currentSplit Current split in bips. See WHO_* contants for keys\\n     * @return Splits in bips using the same keys for the array\\n     */\\n    function arbitrationCalculation(\\n        uint16[5] calldata currentSplit\\n    ) public pure returns (uint16[5] memory) {\\n        uint16[5] memory split;\\n\\n        uint16 calculatedSellerArbitratorFee;\\n        uint16 calculatedBuyerArbitratorFee;\\n\\n        if(currentSplit[WHO_ARBITRATOR] > 0) {\\n            // Calculate buyer's portion of the arbitrator fee\\n            calculatedBuyerArbitratorFee = uint16(\\n                (uint256(currentSplit[WHO_ARBITRATOR])\\n                        * currentSplit[WHO_BUYER])\\n                        / _100_PCT_IN_BIPS\\n            );\\n            \\n             // Seller's portion of the arbitrator fee\\n            calculatedSellerArbitratorFee = uint16(\\n                (uint256(currentSplit[WHO_ARBITRATOR])\\n                    * currentSplit[WHO_SELLER])\\n                    / _100_PCT_IN_BIPS\\n            );\\n            \\n            // Store how much the arbitrator will get from each party\\n            split[WHO_ARBITRATOR] = calculatedBuyerArbitratorFee + calculatedSellerArbitratorFee;\\n        }\\n\\n        // Protocol fee\\n        if (currentSplit[WHO_PROTOCOL] > 0) {\\n            split[WHO_PROTOCOL] = uint16(\\n                (uint256(currentSplit[WHO_PROTOCOL])\\n                    * currentSplit[WHO_SELLER])\\n                    / _100_PCT_IN_BIPS\\n            );\\n        }\\n\\n        // Marketplace fee\\n        if (currentSplit[WHO_MARKETPLACE] > 0) {\\n            split[WHO_MARKETPLACE] = uint16(\\n                (uint256(currentSplit[WHO_MARKETPLACE])\\n                    * currentSplit[WHO_SELLER])\\n                    / _100_PCT_IN_BIPS\\n            );\\n        }\\n\\n        // Substract buyer's portion of the arbitartor fee from their share (if any)\\n        if(currentSplit[WHO_BUYER] > 0) {\\n            split[WHO_BUYER] = uint16(\\n                uint256(currentSplit[WHO_BUYER])\\n                        - calculatedBuyerArbitratorFee\\n                );\\n        }\\n\\n        // Marketplace, protocol, and seller's portion of the arbitartor fee are substracted from seller's share\\n        if(currentSplit[WHO_SELLER] > 0) {\\n            split[WHO_SELLER] = uint16(\\n                uint256(currentSplit[WHO_SELLER])\\n                    - split[WHO_PROTOCOL]\\n                    - split[WHO_MARKETPLACE]\\n                    - calculatedSellerArbitratorFee\\n                );\\n        }\\n\\n        return split;\\n    }\\n\\n    /// @inheritdoc IUnicrowArbitrator\\n    function getArbitratorData(uint256 escrowId)\\n        public\\n        override\\n        view\\n        returns (Arbitrator memory)\\n    {\\n        return escrowArbitrator[escrowId];\\n    }\\n\\n    /**\\n     * @dev Checks whether an address is a buyer in the provided escrow\\n     * @param escrowId Id of the escrow to check against\\n     * @param member_ the address to check\\n     */\\n    function _isEscrowMember(uint256 escrowId, address member_)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        Escrow memory escrow = unicrow.getEscrow(escrowId);\\n        return escrow.buyer == member_ || escrow.seller == member_;\\n    }\\n\\n    /**\\n     * @dev Checks whether an address is a buyer in the provided escrow\\n     * @param escrow Instance of escrow\\n     * @param _buyer the address to check\\n     */\\n    function _isEscrowBuyer(Escrow memory escrow, address _buyer)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return _buyer == escrow.buyer;\\n    }\\n\\n    /**\\n     * @dev Checks whether an address is a seller in the provided escrow\\n     * @param escrow Instance of escrow\\n     * @param _seller the address to check\\n     */\\n    function _isEscrowSeller(Escrow memory escrow, address _seller)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return _seller == escrow.seller;\\n    }\\n}\\n\",\"keccak256\":\"0xf89a9a3b721b8400928bd6b7d9f60b61d1933964947dd0b4c2dc3b6937bb6322\",\"license\":\"MIT\"},\"contracts/UnicrowDispute.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"./interfaces/IUnicrowClaim.sol\\\";\\nimport \\\"./interfaces/IUnicrowDispute.sol\\\";\\nimport \\\"./interfaces/IUnicrowArbitrator.sol\\\";\\nimport \\\"./Unicrow.sol\\\";\\nimport \\\"./UnicrowTypes.sol\\\";\\n\\ncontract UnicrowDispute is IUnicrowDispute, Context, ReentrancyGuard {\\n    using Address for address payable;\\n\\n    /// Main Unicrow's escrow contract\\n    Unicrow public immutable unicrow;\\n\\n    /// Reference to the contract that manages claims from the escrow\\n    IUnicrowClaim public immutable unicrowClaim;\\n\\n    /// Reference to the Arbitration contract\\n    IUnicrowArbitrator public immutable unicrowArbitrator;\\n\\n    /// Stores information about which address sent the latest offer to settle a particular escrow identified by its ID\\n    mapping(uint256 => address) public latestSettlementOfferBy;\\n\\n    /// Stores information about the splits in the latest offer to settle an escrow identified by its ID\\n    mapping(uint256 => uint16[2]) public latestSettlementOffer;\\n\\n    /**\\n     * @dev Emitted when a challenge is sent for an escrow\\n     * @param escrowId ID of the challenged escrow\\n     * @param blockTime Timestamp when the challenge was minted\\n     * @param escrow information about the challenged escrow\\n    */\\n    event Challenge(uint256 indexed escrowId, uint256 blockTime, Escrow escrow);\\n\\n    /**\\n     * @dev Settlement offer (i.e. offer to split the escrow by defined shares) was sent by one of the parties\\n     * @param escrowId ID of the scrow for which a settlement was offered\\n     * @param blockTime Timestamp for when the offer was minted\\n     * @param latestSettlementOffer Splits [buyer's split, seller's split] as defined in the offer (in bips)\\n     * @param latestSettlementOfferBy address which sent the offer\\n     */\\n    event SettlementOffer(uint256 indexed escrowId, uint256 blockTime, uint16[2] latestSettlementOffer, address latestSettlementOfferBy);\\n\\n    /**\\n     * @dev Settlement offer was approved and the escrow was settled and claimed\\n     * @param escrowId ID of the escrow\\n     * @param escrow Details of the escrow\\n     * @param latestSettlementOffer Splits (in bips) in the settlement offer that was approved\\n     * @param blockTime Timestamp of when the settlement was minted\\n     * @param amounts amounts (in token) sent to addresses that were eligible to any shares and fees from the escrow\\n     */\\n    event ApproveOffer(uint256 indexed escrowId, Escrow escrow, uint16[2] latestSettlementOffer,uint256 blockTime, uint256[5] amounts);\\n\\n    /**\\n     * Constructor sets immutable references to the related Unicrow contracts\\n     */\\n    constructor(\\n        address unicrow_,\\n        address unicrowClaim_,\\n        address unicrowArbitrator_\\n    ) {\\n        unicrow = Unicrow(payable(unicrow_));\\n        unicrowClaim = IUnicrowClaim(payable(unicrowClaim_));\\n        unicrowArbitrator = IUnicrowArbitrator(unicrowArbitrator_);\\n    }\\n\\n    /// @inheritdoc IUnicrowDispute\\n    function challenge(uint256 escrowId) external override nonReentrant {\\n        address sender = _msgSender();\\n\\n        Escrow memory escrow = unicrow.getEscrow(escrowId);\\n\\n        // Only the escrow's seller and buyer can challenge\\n        require(sender == escrow.seller || sender == escrow.buyer, \\\"1-009\\\");\\n\\n        // The payment must be either in \\\"Paid\\\" or \\\"Challenged\\\" state\\n        require(\\n            escrow.consensus[WHO_SELLER] <= 0 ||\\n                escrow.consensus[WHO_BUYER] <= 0,\\n            \\\"1-005\\\"\\n        );\\n\\n        // Check that the challenge period is running\\n        require(block.timestamp <= escrow.challengePeriodEnd, \\\"1-016\\\");\\n        require(block.timestamp > escrow.challengePeriodStart, \\\"1-019\\\");\\n\\n        // Prevent reduntant challenge from seller's side\\n        require(\\n            sender != escrow.buyer ||\\n            escrow.consensus[WHO_BUYER] <= 0,\\n            \\\"1-014\\\"\\n        );\\n\\n        // Prevent reduntant challenge from buyer's side\\n        require(\\n            sender != escrow.seller ||\\n            escrow.consensus[WHO_SELLER] <= 0,\\n            \\\"1-015\\\"\\n        );\\n\\n        // Challenge does a few things:\\n        //   - sets split to 100/0% for the challenging party\\n        //   - sets the challenging party's consensus to positive and increases it by one\\n        //   - sets the challenged party consensus to negative\\n        // This way, if one of the parties has negative consensus, we know the payment is challenged\\n        //   and the absolute number keeps track of how many challenges have there been\\n        if (sender == escrow.buyer) {\\n            escrow.split[WHO_BUYER] = 10000;\\n            escrow.split[WHO_SELLER] = 0;\\n            escrow.consensus[WHO_BUYER] = abs8(escrow.consensus[WHO_BUYER]) + 1;\\n            escrow.consensus[WHO_SELLER] = -(abs8(escrow.consensus[WHO_SELLER]));\\n        } else if (sender == escrow.seller) {\\n            escrow.split[WHO_SELLER] = 10000;\\n            escrow.split[WHO_BUYER] = 0;\\n            escrow.consensus[WHO_BUYER] = -(abs8(escrow.consensus[WHO_BUYER]));\\n            escrow.consensus[WHO_SELLER] = abs8(escrow.consensus[WHO_SELLER]) + 1;\\n        }\\n\\n        // The new challenge period starts at the end of the current period\\n        //   and is extended by the time set in the original payment\\n        uint64 periodStart = escrow.challengePeriodEnd;\\n        uint64 periodEnd = escrow.challengePeriodEnd + escrow.challengeExtension;\\n\\n        // Execute the challenge in the main escrow contract\\n        unicrow.challenge(\\n            escrowId,\\n            escrow.split,\\n            escrow.consensus,\\n            periodStart,\\n            periodEnd\\n        );\\n\\n        // Update the challenge periods for the returned event\\n        escrow.challengePeriodStart = periodStart;\\n        escrow.challengePeriodEnd = periodEnd;\\n\\n        emit Challenge(escrowId, block.timestamp, escrow);\\n    }\\n\\n    /// @inheritdoc IUnicrowDispute\\n    function offerSettlement(uint256 escrowId, uint16[2] calldata newSplit)\\n        external\\n        override\\n        nonReentrant\\n    {\\n        address sender = _msgSender();\\n        Escrow memory escrow = unicrow.getEscrow(escrowId);\\n\\n        // Only buyer or seller can offer a settlement\\n        require(sender == escrow.buyer || sender == escrow.seller, \\\"1-009\\\");\\n\\n        // Check that the payment has not been released, refunded, or settled already\\n        require(\\n            escrow.consensus[WHO_SELLER] <= 0 ||\\n                escrow.consensus[WHO_BUYER] <= 0,\\n            \\\"1-005\\\"\\n        );\\n\\n        // Proposed splits should equal 100%\\n        require(newSplit[WHO_BUYER] + newSplit[WHO_SELLER] == 10000, \\\"1-007\\\");\\n\\n        // Record the latest offer details\\n        latestSettlementOfferBy[escrowId] = sender;\\n        latestSettlementOffer[escrowId] = newSplit;\\n\\n        emit SettlementOffer(escrowId, block.timestamp, newSplit, msg.sender);\\n    }\\n\\n    /// @inheritdoc IUnicrowDispute\\n    function approveSettlement(\\n        uint256 escrowId,\\n        uint16[2] calldata validation\\n    ) external override {\\n        address sender = _msgSender();\\n\\n        Escrow memory escrow = unicrow.getEscrow(escrowId);\\n\\n        address latestSettlementOfferByAddress = latestSettlementOfferBy[escrowId];\\n\\n        // Only buyer or seller can approve a settlement\\n        require(sender == escrow.buyer || sender == escrow.seller, \\\"1-009\\\");\\n\\n        // Check that there's a prior settlement offer\\n        require(latestSettlementOfferByAddress != address(0), \\\"1-017\\\");\\n\\n        // Only buyer can approve Seller's offer and vice versa\\n        require(sender != latestSettlementOfferByAddress, \\\"1-020\\\");\\n\\n        uint16[2] memory latestOffer = latestSettlementOffer[escrowId];\\n\\n        // Check that the splits sent for approval are the ones that were offered\\n        require(\\n            validation[WHO_BUYER] == latestOffer[WHO_BUYER] &&\\n            validation[WHO_SELLER] == latestOffer[WHO_SELLER],\\n            \\\"1-018\\\"\\n        );\\n\\n        uint16[4] memory split = escrow.split;\\n\\n        split[WHO_BUYER] = latestOffer[WHO_BUYER];\\n        split[WHO_SELLER] = latestOffer[WHO_SELLER];\\n\\n        // Update buyer and seller consensus to positive numbers\\n        escrow.consensus[WHO_BUYER] = abs8(escrow.consensus[WHO_BUYER]) + 1;\\n        escrow.consensus[WHO_SELLER] = abs8(escrow.consensus[WHO_SELLER]);\\n\\n        // Record the settlement in the main escrow contract\\n        unicrow.settle(\\n            escrowId,\\n            split,\\n            escrow.consensus\\n        );\\n\\n        // Sent shares to all the parties and read the final amounts\\n        uint256[5] memory amounts = unicrowClaim.claim(escrowId);\\n\\n        emit ApproveOffer(escrowId, escrow, latestOffer, block.timestamp, amounts);\\n    }\\n\\n    /**\\n     * Get details about the latest settlement offer\\n     * @param escrowId Id of the escrow to get settlement offer details for\\n     * @return Returns zero values in the returned object's fields if there's been no offer\\n     */\\n    function getSettlementDetails(uint256 escrowId) external view returns (Settlement memory) {\\n       Settlement memory settlement = Settlement(latestSettlementOfferBy[escrowId], latestSettlementOffer[escrowId]);\\n       return settlement;\\n    }\\n}\\n\",\"keccak256\":\"0x85d248b27f4825992cf866ad6538de3c01c7383caea566a97012bbd114694701\",\"license\":\"MIT\"},\"contracts/UnicrowTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nuint16 constant _100_PCT_IN_BIPS = 10000;\\n\\n// these constants are used as keys for consensus and split arrays\\nuint8 constant WHO_BUYER = 0;\\nuint8 constant WHO_SELLER = 1;\\nuint8 constant WHO_MARKETPLACE = 2;\\nuint8 constant WHO_PROTOCOL = 3;\\nuint8 constant WHO_ARBITRATOR = 4;\\n\\n/// @dev This is how information about each escrow is stored int he main contract, mapped to escrowId\\nstruct Escrow {\\n    /// @dev Who sent the payment\\n    address buyer;\\n\\n    /// @dev By how much will the challenge period get extended after a challenge (in seconds)\\n    uint64 challengeExtension;\\n\\n    /// @dev Whom is the payment for\\n    address seller;\\n\\n    /// @dev When does/has the current challenge period start(ed) (seconds in Unix epoch)\\n    uint64 challengePeriodStart;\\n\\n    /// @dev Address of a marketplace that has facilitated the trade (0x000...00 if none)\\n    address marketplace;\\n\\n    /// @dev Fee for the marketplace (can be 0 even if a marketplace was set but doesn't charge fee)\\n    uint256 marketplaceFee;\\n\\n    /// @dev When does the current challenge period end (seconds in Unix epoch)\\n    uint64 challengePeriodEnd;\\n\\n    /// @dev Token used in the payment (0x00..00 for ETH)\\n    address currency;\\n\\n    /// @dev True if the payment was already withdrawn from the escrow\\n    uint16 claimed;\\n\\n    /**\\n     * @dev Indicates status of the payment from buyer's and seller's side.\\n     * Negative value means that party was challenged.\\n     * Examples for various states:\\n     *  0, 1: Paid - If the payment is claimed after challenge period ends, consensus remains like this\\n     *  1, 1: Released by buyer\\n     *  1,-1: 1x Challenged by buyer - If the payment is claimed after CP ends, consensus remains like this\\n     * -1, 2: 1x Challenged by buyer and 1x by Seller\\n     *  2,-2: 2x Challenged by buyer, 1x by seller\\n     *  3, 2: Released, Refunded, or Settled. Deduct 1 from each consensus number to calculate number of challenges\\n     */\\n    int16[2] consensus;\\n\\n    /**\\n     * @dev Buyer's and Seller's share, and fees, in bips\\n     * Example of a new payment with 5% marketplace fee, 5% arbitrator fee: [0, 10000, 500, 500]\\n     * If the payment is refunded: [10000, 0, 0, 0]\\n     * If the payment is settled (e.g. 20% discount for the buyer): [8000, 2000, 500, 500]\\n     *\\n     * Note, that the sum of all splits can equal to more than 100% here.\\n     * The actual fees and shares are re-calculated when the payment is finally claimed\\n     */\\n    uint16[4] split;\\n\\n    /// @dev amount in the token\\n    uint256 amount;\\n}\\n\\n/// @dev Escrow parameters to be sent along with the deposit\\nstruct EscrowInput {\\n    /// @dev who should receive the payment\\n    address seller;\\n\\n    /// @dev address of a marketplace that has facilitated the payment\\n    address marketplace;\\n\\n    /// @dev Fee for the marketplace (can be 0 even if a marketplace was set but doesn't charge fee)\\n    uint16 marketplaceFee;\\n\\n    /// @dev Token used in the payment (0x00..00 for ETH)\\n    address currency;\\n\\n    /// @dev Initial challenge period (in seconds)\\n    uint32 challengePeriod;\\n\\n    /// @dev By how much will the challenge period get extended after a challenge (in seconds)\\n    uint32 challengeExtension;\\n\\n    /// @dev Amount in token\\n    uint256 amount;\\n}\\n\\n/// @dev Information about arbitrator proposed or assigned to an escrow.\\n/// @dev If both buyerConsensus and sellerConsensus are 1, the arbitrator is assigned, otherwise it's only been proposed by the party that has 1\\nstruct Arbitrator {\\n    /// @dev Address of the arbitrator. 0x00..00 for no arbitrator\\n    address arbitrator;\\n\\n    /// @dev Arbitrator's fee in bips. Can be 0\\n    uint16 arbitratorFee;\\n\\n    /// @dev Seller's agreement on the arbitrator\\n    bool sellerConsensus;\\n\\n    /// @dev Buyer's agreement on the arbitrator\\n    bool buyerConsensus;\\n\\n    /// @dev Has the escrow been decided by the arbitrator\\n    bool arbitrated;\\n}\\n\\n/// @dev Stores information about settlement, mapped to escrowId in UnicrowDispute contract\\nstruct Settlement {\\n    /// @dev address of who sent the latest settlement offer. Returns 0x00..00 if no offer has been made\\n    address latestSettlementOfferBy;\\n\\n    /// @dev how the payment was offered to be settled [buyer, seller] in bips\\n    uint16[2] latestSettlementOffer;\\n}\\n\\n/// @dev Information about the token used in the payment is returned in this structure\\nstruct Token {\\n    address address_;\\n    uint8 decimals;\\n    string symbol;\\n}\\n\\n/// @dev Superstructure that includes all the information relevant to an escrow\\nstruct Data {\\n    Escrow escrow;\\n    Arbitrator arbitrator;\\n    Settlement settlement;\\n    Token token;\\n}\\n\\nfunction abs8(int16 x) pure returns (int16) {\\n    return x >= 0 ? x : -x;\\n}\",\"keccak256\":\"0xa170d9db7e9d975040c77d136e07b6267dca24dea097b8c5fbdb98c4291031c1\",\"license\":\"MIT\"},\"contracts/interfaces/IUnicrow.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.7;\\n\\nimport \\\"../UnicrowTypes.sol\\\";\\n\\ninterface IUnicrow {\\n  /**\\n   * @notice Deposit ETH or SafeERC20 to open a new escrow payment.\\n   * @notice We don't white- or black-list, but we strongly discourage users from using ERC777 tokens\\n   * @notice   and any ERC20 tokens which perform extra logic in their transfer functions. \\n   * @notice If the balance claiming transaction fails due to the token's contract error or malicious behavior, \\n   * @notice   it is not possible to try to claim the balance again.\\n   * @dev Escrow ID is generated automatically by the contract\\n   * @param input Escrow input (seller, marketplace, currency, and challenge period information)\\n   * @param arbitrator Arbitrator address (submit zero address to not set an arbitrator)\\n   * @param arbitratorFee Arbitrator Fee\\n   */\\n  function pay(\\n    EscrowInput memory input,\\n    address arbitrator,\\n    uint16 arbitratorFee\\n  ) external payable;\\n\\n  /**\\n   * @notice Function called by UnicrowDispute to execute a challenge\\n   * @dev can be called by UnicrowDispute only\\n   * @param escrowId ID of the challenged escrow payment\\n   * @param split New split (bips)\\n   * @param consensus New consensus\\n   * @param challengeStart When the new challenge period starts\\n   * @param challengeEnd When the new challenge period ends\\n   */\\n  function challenge(\\n    uint256 escrowId,\\n    uint16[4] memory split,\\n    int16[2] memory consensus,\\n    uint64 challengeStart,\\n    uint64 challengeEnd\\n  ) external;\\n\\n  /**\\n   * @notice Refund 100% of the buyer payment (all fees are waived).\\n   * @dev Can be called only by the Seller\\n   * @param escrowId ID of the escrow to be refunded\\n   */\\n  function refund(uint escrowId) external;\\n\\n  /**\\n   * @notice Release the payment to the seller and to all other parties that charge a fee from it.\\n   * @dev Can be called by the Buyer only\\n   * @param escrowId ID of the escrow to be released\\n   */\\n  function release(uint escrowId) external;\\n\\n  /**\\n   * @notice Settle a payment (i.e. split it with arbitrary shares between the buyer and the seller). Fees are reduced proportionally to the seller's share.\\n   * @dev Can be called only by UnicrowDispute\\n   * @param escrowId ID of the escrow to be settled\\n   * @param split New split in bips (total must equal 10000)\\n   * @param consensus New consensus\\n   */\\n  function settle(\\n    uint256 escrowId,\\n    uint16[4] memory split,\\n    int16[2] memory consensus\\n    ) external;\\n\\n  /**\\n   * @notice Calculating the final splits (incl. fees) based on how the payment is concluded.\\n   * @dev The currentSplit is not expected to equal 100% in total. Buyer and seller splits should equal 100 based\\n   * on how the payment is settled, other splits represent fees which will get reduced and deducted accordingly\\n   * @param currentSplit Current splits in bips\\n   */\\n  function splitCalculation(\\n    uint16[5] calldata currentSplit\\n  ) external returns(uint16[5] memory);\\n\\n  /**\\n   * @dev Get the escrow data (without arbitrator or settlement information)\\n   * @param escrowId ID of the escrow to retrieve information of\\n   */\\n  function getEscrow(\\n    uint256 escrowId\\n  ) external returns(Escrow memory);\\n\\n  /**\\n   * @notice Set the escrow as claimed (i.e. that its balance has been sent to all the parties involved).\\n   * @dev Callable only by other Unicrow contracts\\n   * @param escrowId ID of the escrow to set as claimed\\n   */\\n  function setClaimed(uint escrowId) external;\\n\\n  /**\\n   * @notice Update protocol fee (governance only, cannot be more than 1%)\\n   * @param fee New protocol fee (bips)\\n   */\\n  function updateEscrowFee(uint16 fee) external;\\n\\n  /**\\n   * @notice Update governance contract address (governable)\\n   * @param governance New governance address\\n   */\\n  function updateGovernance(address governance) external;\\n}\\n\",\"keccak256\":\"0xea7694ef3e4affe0cbf2dfb619ce94312548558b2609bd978a8a2e3023206070\",\"license\":\"GPL-2.0-or-later\"},\"contracts/interfaces/IUnicrowArbitrator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"../UnicrowTypes.sol\\\";\\n\\ninterface IUnicrowArbitrator {\\n    /**\\n     * Assigns an arbitrator to an escrow.\\n     * @dev Called by Unicrow.pay()\\n     * @param escrowId Id of the escrow\\n     * @param arbitrator Arbitrator's address\\n     * @param arbitratorFee Arbitrator fee in bips (can be 0)\\n      */\\n    function setArbitrator(uint256 escrowId, address arbitrator, uint16 arbitratorFee) external;\\n\\n    /**\\n     * One of the parties (buyer or seller) can call this to propose an arbitrator\\n     * for an escrow that has no arbitrator defined\\n     * @param escrowId Id of the escrow\\n     * @param arbitrator Arbitrator's address\\n     * @param arbitratorFee Arbitrator fee in bips (can be 0)\\n      */\\n    function proposeArbitrator(uint256 escrowId, address arbitrator, uint16 arbitratorFee) external;\\n\\n    /**\\n     * Approve an arbitrator proposed by another party (i.e. by seller if buyer proposed, by buyer if seller proposed).\\n     * @dev To ensure the user approves an arbitrator they wanted, it requires the same parameters as proposal\\n     * @param escrowId Id of an escrow\\n     * @param validationAddress Arbitrator's address - will be compared with the existing proposal\\n     * @param validation Arbitrator's Fee - will be compared with the existing proposal\\n    */\\n    function approveArbitrator(uint256 escrowId, address validationAddress, uint16 validation) external;\\n\\n    /**\\n     * Arbitrate an payment - to be called only by an escrow's arbitrator\\n     * @param escrowId Id of an escrow\\n     * @param newSplit How the payment should be split between buyer [0] and seller [1]. [100, 0] will refund the payment to the buyer, [0, 100] will release it to the seller, anything in between will\\n     */\\n    function arbitrate(uint256 escrowId, uint16[2] memory newSplit) external;\\n\\n    /**\\n     * Get information about proposed or assigned arbitrator.\\n     * @dev buyerConsensus and sellerConsensus indicate if the arbitrator was only proposed by one of the parties or\\n     * @dev has been assigned by the mutual consensus\\n     * @return Arbitrator information.\\n     * @param escrowId ID of the escrow\\n     */\\n    function getArbitratorData(uint256 escrowId) external view returns(Arbitrator memory);\\n}\\n\",\"keccak256\":\"0xf8f2df97eca4816ce542763bd459eff9c649ba85c70eb573a9451644dbea6357\",\"license\":\"MIT\"},\"contracts/interfaces/IUnicrowClaim.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface IUnicrowClaim {\\n    /// @notice Claim multiple escrows.\\n    /// @dev To save everyone's gas costs, it claims balances and fees of all parties that are eligible for a share from the escrow\\n    /// @param escrows List of escrows to be claimed.\\n    function claimMultiple(uint[] memory escrows) external;\\n\\n    /// @notice Claim a single escrow\\n    /// @dev To save everyone's gas costs, it claims balances and fees of all parties that are eligible for a share from the escrow\\n    /// @param escrowId escrow to be claimed\\n    function claim(uint escrowId) external returns(uint256[5] memory);\\n\\n    // @notice Update rewards contract pointer (governable)\\n    // @param crowRewards_ New rewards address\\n    function updateCrowRewards(address crowRewards_) external;\\n\\n    // @notice Update staking rewards contract pointer (governable)\\n    // @param stakingRewards_ New staking rewards address\\n    function updateStakingRewards(address crowRewards_) external;\\n\\n    // @notice Update protocol fee collection address (governable)\\n    // @param protocolFeeAddress_ New protocol fee collection address\\n    function updateProtocolFeeAddress(address protocolFeeAddress_) external;\\n}\\n\",\"keccak256\":\"0x143bfdf568bf9897babb4644ac5faa4ba866635b4b176b9c2bce6f25bf458d95\",\"license\":\"MIT\"},\"contracts/interfaces/IUnicrowDispute.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\nimport \\\"../UnicrowTypes.sol\\\";\\n\\ninterface IUnicrowDispute {\\n  /**\\n   * Challenge a payment. If the challenge is successful (the criteria are met),\\n   * it sets whoever sent the challenge as a payee and sets a new challenge period\\n   * @param escrowId Id of the escrow that's being challenged\\n   */\\n  function challenge(uint256 escrowId) external;\\n\\n  /**\\n   * Send an offer to settle the payment between the buyer and the seller\\n   * @param escrowId ID of the escrow for which the offer is sent\\n   * @param newSplit the new settlement proposal ([buyerSplit, sellerSplit] in bips, sum must equal 10000)\\n   */\\n  function offerSettlement(uint256 escrowId, uint16[2] memory newSplit) external;\\n\\n  /**\\n   * Approve an offer to settle the payment between the buyer and the seller\\n   * @param escrowId ID of the escrow for which the offer is sent\\n   * @param validation the settlement proposal that must be equal to an offer sent by the other party\\n   */\\n  function approveSettlement(uint256 escrowId,uint16[2] memory validation) external;\\n}\\n\",\"keccak256\":\"0x8d3220d0acac753e2fd1b0d8d7b2ea05e27805358794a8ee278e41c943381fc7\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c06040523480156200001157600080fd5b5060405162001a3d38038062001a3d833981016040819052620000349162000075565b60016000556001600160601b0319606092831b8116608052911b1660a052620000ad565b80516001600160a01b03811681146200007057600080fd5b919050565b600080604083850312156200008957600080fd5b620000948362000058565b9150620000a46020840162000058565b90509250929050565b60805160601c60a05160601c6119336200010a6000396000818161025e015261075f01526000818161016601528181610322015281816103fd0152818161067c01528181610acb01528181610e60015261114a01526119336000f3fe608060405234801561001057600080fd5b50600436106100a35760003560e01c80636e4e2934116100765780638e032c5a1161005b5780638e032c5a146101b3578063e2bc475c146101c6578063e9db7d791461025957600080fd5b80636e4e29341461016157806379414b3c146101a057600080fd5b806316e0551b146100a85780632ea8eddd14610119578063496f928b1461012e5780634c403c5314610141575b600080fd5b6100bb6100b636600461150e565b610280565b6040516101109190600060a0820190506001600160a01b03835116825261ffff602084015116602083015260408301511515604083015260608301511515606083015260808301511515608083015292915050565b60405180910390f35b61012c610127366004611527565b61031f565b005b61012c61013c366004611569565b6103ce565b61015461014f366004611362565b610820565b6040516101109190611612565b6101887f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610110565b61012c6101ae366004611527565b610a64565b61012c6101c1366004611527565b610df1565b61021c6101d436600461150e565b6001602052600090815260409020546001600160a01b0381169061ffff600160a01b8204169060ff600160b01b8204811691600160b81b8104821691600160c01b9091041685565b604080516001600160a01b03909616865261ffff90941660208601529115159284019290925290151560608301521515608082015260a001610110565b6101887f000000000000000000000000000000000000000000000000000000000000000081565b6040805160a08101825260008082526020820181905291810182905260608101829052608081019190915250600090815260016020908152604091829020825160a08101845290546001600160a01b038116825261ffff600160a01b8204169282019290925260ff600160b01b83048116151593820193909352600160b81b8204831615156060820152600160c01b9091049091161515608082015290565b337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161461035457600080fd5b60009283526001602052604090922080547701010000000000000000000000000000000000000000000061ffff60b01b1961ffff909516600160a01b027fffffffffffffffffffff000000000000000000000000000000000000000000009092166001600160a01b03909416939093171792909216179055565b60006103d983610280565b604051633e8cf2cb60e11b8152600481018590529091506000906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690637d19e596906024016102006040518083038186803b15801561044057600080fd5b505afa158015610454573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104789190611405565b82519091506001600160a01b0316336001600160a01b0316146104e25760405162461bcd60e51b815260206004820152600560248201527f322d30303500000000000000000000000000000000000000000000000000000060448201526064015b60405180910390fd5b816060015180156104f4575081604001515b6105405760405162461bcd60e51b815260206004820152600560248201527f322d30303100000000000000000000000000000000000000000000000000000060448201526064016104d9565b61055060408401602085016114ea565b61055d60208501856114ea565b61056791906117f1565b61ffff16612710146105bb5760405162461bcd60e51b815260206004820152600560248201527f312d30303700000000000000000000000000000000000000000000000000000060448201526064016104d9565b6101208101516105d29060005b6020020151611104565b6105dd9060016117ac565b61012082018051600192830b830b9052516105f7916105c8565b610120820151600191820b90910b602091820152610617908401846114ea565b61014082015161ffff91909116905261063660408401602085016114ea565b6101408201805161ffff92909216602090920191909152516101208201516040517f64166e630000000000000000000000000000000000000000000000000000000081527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316926364166e63926106bb9289929190600401611761565b600060405180830381600087803b1580156106d557600080fd5b505af11580156106e9573d6000803e3d6000fd5b50505060008581526001602052604080822080547fffffffffffffff00ffffffffffffffffffffffffffffffffffffffffffffffff16600160c01b179055517f379607f5000000000000000000000000000000000000000000000000000000008152600481018790529091506001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063379607f59060240160a060405180830381600087803b1580156107a357600080fd5b505af11580156107b7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107db919061138a565b9050847f078c1bd0728767e70d5913396262af1d8c75f3daa7a80c3c6af9594909bf806383428460405161081193929190611647565b60405180910390a25050505050565b610828611208565b610830611208565b6000808061084460a08701608088016114ea565b61ffff1611156108e15761271061085e60208701876114ea565b61ffff1661087260a08801608089016114ea565b61ffff166108809190611851565b61088a919061182f565b905061271061089f60408701602088016114ea565b61ffff166108b360a08801608089016114ea565b61ffff166108c19190611851565b6108cb919061182f565b91506108d782826117f1565b61ffff1660808401525b60006108f360808701606088016114ea565b61ffff1611156109465761271061091060408701602088016114ea565b61ffff1661092460808801606089016114ea565b61ffff166109329190611851565b61093c919061182f565b61ffff1660608401525b600061095860608701604088016114ea565b61ffff1611156109ab5761271061097560408701602088016114ea565b61ffff1661098960608801604089016114ea565b61ffff166109979190611851565b6109a1919061182f565b61ffff1660408401525b60006109ba60208701876114ea565b61ffff1611156109eb5761ffff81166109d660208701876114ea565b61ffff166109e49190611870565b61ffff1683525b60006109fd60408701602088016114ea565b61ffff161115610a5b57604080840151606085015161ffff8581169392811692911690610a2f90890160208a016114ea565b61ffff16610a3d9190611870565b610a479190611870565b610a519190611870565b61ffff1660208401525b50909392505050565b8233610a708282611127565b610aa45760405162461bcd60e51b81526020600482015260056024820152640c8b4c0c0d60da1b60448201526064016104d9565b6000858152600160205260408082209051633e8cf2cb60e11b8152600481018890529091907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690637d19e596906024016102006040518083038186803b158015610b1657600080fd5b505afa158015610b2a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b4e9190611405565b90506001600160a01b038616610ba65760405162461bcd60e51b815260206004820152600560248201527f322d30303900000000000000000000000000000000000000000000000000000060448201526064016104d9565b80516001600160a01b03878116911614801590610bd9575080604001516001600160a01b0316866001600160a01b031614155b610c255760405162461bcd60e51b815260206004820152600560248201527f322d30313000000000000000000000000000000000000000000000000000000060448201526064016104d9565b8154600160b81b900460ff161580610c4657508154600160b01b900460ff16155b610c925760405162461bcd60e51b815260206004820152600560248201527f322d30303600000000000000000000000000000000000000000000000000000060448201526064016104d9565b6101408101516127109061ffff8716906003602002015161ffff168360a00151610cbc9190611817565b610cc69190611817565b10610cfb5760405162461bcd60e51b8152602060048201526005602482015264322d30303760d81b60448201526064016104d9565b81546001600160a01b0387167fffffffffffffffffffff0000000000000000000000000000000000000000000090911617600160a01b61ffff871602178255610d52813390516001600160a01b0390811691161490565b15610d6e57815461ffff60b01b1916600160b81b178255610d96565b60408101516001600160a01b0316331415610d9657815461ffff60b01b1916600160b01b1782555b604080516001600160a01b038816815261ffff87166020820152339181019190915287907fbf42827f17777ed92b098fa9e5f6823ecb5c116e3b23909cc242530b1784dbbc906060015b60405180910390a250505050505050565b8233610dfd8282611127565b610e315760405162461bcd60e51b81526020600482015260056024820152640c8b4c0c0d60da1b60448201526064016104d9565b6000610e3c86610280565b604051633e8cf2cb60e11b8152600481018890529091506000906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690637d19e596906024016102006040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190611405565b82519091506001600160a01b0316610f1d5760405162461bcd60e51b81526020600482015260056024820152640645a6060760db1b60448201526064016104d9565b81516001600160a01b03878116911614610f615760405162461bcd60e51b81526020600482015260056024820152640645a6060760db1b60448201526064016104d9565b816020015161ffff168561ffff1614610fa45760405162461bcd60e51b8152602060048201526005602482015264322d30303760d81b60448201526064016104d9565b80516001600160a01b031633141561102b57606082015115610ff05760405162461bcd60e51b8152602060048201526005602482015264322d30303360d81b60448201526064016104d9565b600087815260016020526040902080547fffffffffffffffff00ffffffffffffffffffffffffffffffffffffffffffffff16600160b81b1790555b60408101516001600160a01b03163314156110b55760408201511561107a5760405162461bcd60e51b8152602060048201526005602482015264322d30303360d81b60448201526064016104d9565b600087815260016020526040902080547fffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffffffff16600160b01b1790555b8151602083015160405189927fd514ca74d69a194b5d9455914d0d20ef96d29b6177b241c9d5f608264055199c92610de0926001600160a01b0392909216825261ffff16602082015260400190565b6000808260010b121561111f5761111a82611887565b611121565b815b92915050565b604051633e8cf2cb60e11b81526004810183905260009081906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690637d19e596906024016102006040518083038186803b15801561118d57600080fd5b505afa1580156111a1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111c59190611405565b9050826001600160a01b031681600001516001600160a01b031614806112005750826001600160a01b031681604001516001600160a01b0316145b949350505050565b6040518060a001604052806005906020820280368337509192915050565b8051611231816118d5565b919050565b600082601f83011261124757600080fd5b6040516040810181811067ffffffffffffffff8211171561126a5761126a6118bf565b806040525080838560408601111561128157600080fd5b6000805b60028110156112b35782518060010b811461129e578283fd5b84526020938401939290920191600101611285565b50929695505050505050565b600082601f8301126112d057600080fd5b6040516080810181811067ffffffffffffffff821117156112f3576112f36118bf565b60405280836080810186101561130857600080fd5b60005b600481101561133457815161131f816118ed565b8352602092830192919091019060010161130b565b509195945050505050565b8051611231816118ed565b805167ffffffffffffffff8116811461123157600080fd5b600060a0828403121561137457600080fd5b8260a08301111561138457600080fd5b50919050565b600060a0828403121561139c57600080fd5b82601f8301126113ab57600080fd5b60405160a0810181811067ffffffffffffffff821117156113ce576113ce6118bf565b604052808360a081018610156113e357600080fd5b60005b60058110156113345781518352602092830192909101906001016113e6565b6000610200828403121561141857600080fd5b611420611782565b61142983611226565b81526114376020840161134a565b602082015261144860408401611226565b60408201526114596060840161134a565b606082015261146a60808401611226565b608082015260a083015160a082015261148560c0840161134a565b60c082015261149660e08401611226565b60e08201526101006114a981850161133f565b908201526101206114bc85858301611236565b908201526101606114cf858583016112bf565b6101408301526101e084015181830152508091505092915050565b6000602082840312156114fc57600080fd5b8135611507816118ed565b9392505050565b60006020828403121561152057600080fd5b5035919050565b60008060006060848603121561153c57600080fd5b83359250602084013561154e816118d5565b9150604084013561155e816118ed565b809150509250925092565b6000806060838503121561157c57600080fd5b823591508360608401111561159057600080fd5b50926020919091019150565b8060005b60028110156115c2578151600190810b855260209485019490920191016115a0565b50505050565b8060005b60048110156115c257815161ffff168452602093840193909101906001016115cc565b8060005b60058110156115c25781518452602093840193909101906001016115f3565b60a08101818360005b600581101561163e57815161ffff1683526020928301929091019060010161161b565b50505092915050565b83516001600160a01b031681526102c081016020850151611674602084018267ffffffffffffffff169052565b50604085015161168f60408401826001600160a01b03169052565b5060608501516116ab606084018267ffffffffffffffff169052565b5060808501516116c660808401826001600160a01b03169052565b5060a085015160a083015260c08501516116ec60c084018267ffffffffffffffff169052565b5060e085015161170760e08401826001600160a01b03169052565b506101008581015161ffff16908301526101208086015161172a8285018261159c565b5050610140850151610160611741818501836115c8565b8601516101e08401525061020082018490526112006102208301846115ef565b83815260e0810161177560208301856115c8565b61120060a083018461159c565b604051610180810167ffffffffffffffff811182821017156117a6576117a66118bf565b60405290565b60008160010b8360010b6000821282617fff038213811516156117d1576117d16118a9565b82617fff190382128116156117e8576117e86118a9565b50019392505050565b600061ffff80831681851680830382111561180e5761180e6118a9565b01949350505050565b6000821982111561182a5761182a6118a9565b500190565b60008261184c57634e487b7160e01b600052601260045260246000fd5b500490565b600081600019048311821515161561186b5761186b6118a9565b500290565b600082821015611882576118826118a9565b500390565b60008160010b617fff198114156118a0576118a06118a9565b60000392915050565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b03811681146118ea57600080fd5b50565b61ffff811681146118ea57600080fdfea26469706673582212204c16672b65f7ada3cbf8a0d226af782f701748b77b23bf981ad80327f1fe910364736f6c63430008070033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100a35760003560e01c80636e4e2934116100765780638e032c5a1161005b5780638e032c5a146101b3578063e2bc475c146101c6578063e9db7d791461025957600080fd5b80636e4e29341461016157806379414b3c146101a057600080fd5b806316e0551b146100a85780632ea8eddd14610119578063496f928b1461012e5780634c403c5314610141575b600080fd5b6100bb6100b636600461150e565b610280565b6040516101109190600060a0820190506001600160a01b03835116825261ffff602084015116602083015260408301511515604083015260608301511515606083015260808301511515608083015292915050565b60405180910390f35b61012c610127366004611527565b61031f565b005b61012c61013c366004611569565b6103ce565b61015461014f366004611362565b610820565b6040516101109190611612565b6101887f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610110565b61012c6101ae366004611527565b610a64565b61012c6101c1366004611527565b610df1565b61021c6101d436600461150e565b6001602052600090815260409020546001600160a01b0381169061ffff600160a01b8204169060ff600160b01b8204811691600160b81b8104821691600160c01b9091041685565b604080516001600160a01b03909616865261ffff90941660208601529115159284019290925290151560608301521515608082015260a001610110565b6101887f000000000000000000000000000000000000000000000000000000000000000081565b6040805160a08101825260008082526020820181905291810182905260608101829052608081019190915250600090815260016020908152604091829020825160a08101845290546001600160a01b038116825261ffff600160a01b8204169282019290925260ff600160b01b83048116151593820193909352600160b81b8204831615156060820152600160c01b9091049091161515608082015290565b337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161461035457600080fd5b60009283526001602052604090922080547701010000000000000000000000000000000000000000000061ffff60b01b1961ffff909516600160a01b027fffffffffffffffffffff000000000000000000000000000000000000000000009092166001600160a01b03909416939093171792909216179055565b60006103d983610280565b604051633e8cf2cb60e11b8152600481018590529091506000906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690637d19e596906024016102006040518083038186803b15801561044057600080fd5b505afa158015610454573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104789190611405565b82519091506001600160a01b0316336001600160a01b0316146104e25760405162461bcd60e51b815260206004820152600560248201527f322d30303500000000000000000000000000000000000000000000000000000060448201526064015b60405180910390fd5b816060015180156104f4575081604001515b6105405760405162461bcd60e51b815260206004820152600560248201527f322d30303100000000000000000000000000000000000000000000000000000060448201526064016104d9565b61055060408401602085016114ea565b61055d60208501856114ea565b61056791906117f1565b61ffff16612710146105bb5760405162461bcd60e51b815260206004820152600560248201527f312d30303700000000000000000000000000000000000000000000000000000060448201526064016104d9565b6101208101516105d29060005b6020020151611104565b6105dd9060016117ac565b61012082018051600192830b830b9052516105f7916105c8565b610120820151600191820b90910b602091820152610617908401846114ea565b61014082015161ffff91909116905261063660408401602085016114ea565b6101408201805161ffff92909216602090920191909152516101208201516040517f64166e630000000000000000000000000000000000000000000000000000000081527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316926364166e63926106bb9289929190600401611761565b600060405180830381600087803b1580156106d557600080fd5b505af11580156106e9573d6000803e3d6000fd5b50505060008581526001602052604080822080547fffffffffffffff00ffffffffffffffffffffffffffffffffffffffffffffffff16600160c01b179055517f379607f5000000000000000000000000000000000000000000000000000000008152600481018790529091506001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063379607f59060240160a060405180830381600087803b1580156107a357600080fd5b505af11580156107b7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107db919061138a565b9050847f078c1bd0728767e70d5913396262af1d8c75f3daa7a80c3c6af9594909bf806383428460405161081193929190611647565b60405180910390a25050505050565b610828611208565b610830611208565b6000808061084460a08701608088016114ea565b61ffff1611156108e15761271061085e60208701876114ea565b61ffff1661087260a08801608089016114ea565b61ffff166108809190611851565b61088a919061182f565b905061271061089f60408701602088016114ea565b61ffff166108b360a08801608089016114ea565b61ffff166108c19190611851565b6108cb919061182f565b91506108d782826117f1565b61ffff1660808401525b60006108f360808701606088016114ea565b61ffff1611156109465761271061091060408701602088016114ea565b61ffff1661092460808801606089016114ea565b61ffff166109329190611851565b61093c919061182f565b61ffff1660608401525b600061095860608701604088016114ea565b61ffff1611156109ab5761271061097560408701602088016114ea565b61ffff1661098960608801604089016114ea565b61ffff166109979190611851565b6109a1919061182f565b61ffff1660408401525b60006109ba60208701876114ea565b61ffff1611156109eb5761ffff81166109d660208701876114ea565b61ffff166109e49190611870565b61ffff1683525b60006109fd60408701602088016114ea565b61ffff161115610a5b57604080840151606085015161ffff8581169392811692911690610a2f90890160208a016114ea565b61ffff16610a3d9190611870565b610a479190611870565b610a519190611870565b61ffff1660208401525b50909392505050565b8233610a708282611127565b610aa45760405162461bcd60e51b81526020600482015260056024820152640c8b4c0c0d60da1b60448201526064016104d9565b6000858152600160205260408082209051633e8cf2cb60e11b8152600481018890529091907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690637d19e596906024016102006040518083038186803b158015610b1657600080fd5b505afa158015610b2a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b4e9190611405565b90506001600160a01b038616610ba65760405162461bcd60e51b815260206004820152600560248201527f322d30303900000000000000000000000000000000000000000000000000000060448201526064016104d9565b80516001600160a01b03878116911614801590610bd9575080604001516001600160a01b0316866001600160a01b031614155b610c255760405162461bcd60e51b815260206004820152600560248201527f322d30313000000000000000000000000000000000000000000000000000000060448201526064016104d9565b8154600160b81b900460ff161580610c4657508154600160b01b900460ff16155b610c925760405162461bcd60e51b815260206004820152600560248201527f322d30303600000000000000000000000000000000000000000000000000000060448201526064016104d9565b6101408101516127109061ffff8716906003602002015161ffff168360a00151610cbc9190611817565b610cc69190611817565b10610cfb5760405162461bcd60e51b8152602060048201526005602482015264322d30303760d81b60448201526064016104d9565b81546001600160a01b0387167fffffffffffffffffffff0000000000000000000000000000000000000000000090911617600160a01b61ffff871602178255610d52813390516001600160a01b0390811691161490565b15610d6e57815461ffff60b01b1916600160b81b178255610d96565b60408101516001600160a01b0316331415610d9657815461ffff60b01b1916600160b01b1782555b604080516001600160a01b038816815261ffff87166020820152339181019190915287907fbf42827f17777ed92b098fa9e5f6823ecb5c116e3b23909cc242530b1784dbbc906060015b60405180910390a250505050505050565b8233610dfd8282611127565b610e315760405162461bcd60e51b81526020600482015260056024820152640c8b4c0c0d60da1b60448201526064016104d9565b6000610e3c86610280565b604051633e8cf2cb60e11b8152600481018890529091506000906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690637d19e596906024016102006040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190611405565b82519091506001600160a01b0316610f1d5760405162461bcd60e51b81526020600482015260056024820152640645a6060760db1b60448201526064016104d9565b81516001600160a01b03878116911614610f615760405162461bcd60e51b81526020600482015260056024820152640645a6060760db1b60448201526064016104d9565b816020015161ffff168561ffff1614610fa45760405162461bcd60e51b8152602060048201526005602482015264322d30303760d81b60448201526064016104d9565b80516001600160a01b031633141561102b57606082015115610ff05760405162461bcd60e51b8152602060048201526005602482015264322d30303360d81b60448201526064016104d9565b600087815260016020526040902080547fffffffffffffffff00ffffffffffffffffffffffffffffffffffffffffffffff16600160b81b1790555b60408101516001600160a01b03163314156110b55760408201511561107a5760405162461bcd60e51b8152602060048201526005602482015264322d30303360d81b60448201526064016104d9565b600087815260016020526040902080547fffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffffffff16600160b01b1790555b8151602083015160405189927fd514ca74d69a194b5d9455914d0d20ef96d29b6177b241c9d5f608264055199c92610de0926001600160a01b0392909216825261ffff16602082015260400190565b6000808260010b121561111f5761111a82611887565b611121565b815b92915050565b604051633e8cf2cb60e11b81526004810183905260009081906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690637d19e596906024016102006040518083038186803b15801561118d57600080fd5b505afa1580156111a1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111c59190611405565b9050826001600160a01b031681600001516001600160a01b031614806112005750826001600160a01b031681604001516001600160a01b0316145b949350505050565b6040518060a001604052806005906020820280368337509192915050565b8051611231816118d5565b919050565b600082601f83011261124757600080fd5b6040516040810181811067ffffffffffffffff8211171561126a5761126a6118bf565b806040525080838560408601111561128157600080fd5b6000805b60028110156112b35782518060010b811461129e578283fd5b84526020938401939290920191600101611285565b50929695505050505050565b600082601f8301126112d057600080fd5b6040516080810181811067ffffffffffffffff821117156112f3576112f36118bf565b60405280836080810186101561130857600080fd5b60005b600481101561133457815161131f816118ed565b8352602092830192919091019060010161130b565b509195945050505050565b8051611231816118ed565b805167ffffffffffffffff8116811461123157600080fd5b600060a0828403121561137457600080fd5b8260a08301111561138457600080fd5b50919050565b600060a0828403121561139c57600080fd5b82601f8301126113ab57600080fd5b60405160a0810181811067ffffffffffffffff821117156113ce576113ce6118bf565b604052808360a081018610156113e357600080fd5b60005b60058110156113345781518352602092830192909101906001016113e6565b6000610200828403121561141857600080fd5b611420611782565b61142983611226565b81526114376020840161134a565b602082015261144860408401611226565b60408201526114596060840161134a565b606082015261146a60808401611226565b608082015260a083015160a082015261148560c0840161134a565b60c082015261149660e08401611226565b60e08201526101006114a981850161133f565b908201526101206114bc85858301611236565b908201526101606114cf858583016112bf565b6101408301526101e084015181830152508091505092915050565b6000602082840312156114fc57600080fd5b8135611507816118ed565b9392505050565b60006020828403121561152057600080fd5b5035919050565b60008060006060848603121561153c57600080fd5b83359250602084013561154e816118d5565b9150604084013561155e816118ed565b809150509250925092565b6000806060838503121561157c57600080fd5b823591508360608401111561159057600080fd5b50926020919091019150565b8060005b60028110156115c2578151600190810b855260209485019490920191016115a0565b50505050565b8060005b60048110156115c257815161ffff168452602093840193909101906001016115cc565b8060005b60058110156115c25781518452602093840193909101906001016115f3565b60a08101818360005b600581101561163e57815161ffff1683526020928301929091019060010161161b565b50505092915050565b83516001600160a01b031681526102c081016020850151611674602084018267ffffffffffffffff169052565b50604085015161168f60408401826001600160a01b03169052565b5060608501516116ab606084018267ffffffffffffffff169052565b5060808501516116c660808401826001600160a01b03169052565b5060a085015160a083015260c08501516116ec60c084018267ffffffffffffffff169052565b5060e085015161170760e08401826001600160a01b03169052565b506101008581015161ffff16908301526101208086015161172a8285018261159c565b5050610140850151610160611741818501836115c8565b8601516101e08401525061020082018490526112006102208301846115ef565b83815260e0810161177560208301856115c8565b61120060a083018461159c565b604051610180810167ffffffffffffffff811182821017156117a6576117a66118bf565b60405290565b60008160010b8360010b6000821282617fff038213811516156117d1576117d16118a9565b82617fff190382128116156117e8576117e86118a9565b50019392505050565b600061ffff80831681851680830382111561180e5761180e6118a9565b01949350505050565b6000821982111561182a5761182a6118a9565b500190565b60008261184c57634e487b7160e01b600052601260045260246000fd5b500490565b600081600019048311821515161561186b5761186b6118a9565b500290565b600082821015611882576118826118a9565b500390565b60008160010b617fff198114156118a0576118a06118a9565b60000392915050565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b03811681146118ea57600080fd5b50565b61ffff811681146118ea57600080fdfea26469706673582212204c16672b65f7ada3cbf8a0d226af782f701748b77b23bf981ad80327f1fe910364736f6c63430008070033",
  "devdoc": {
    "events": {
      "Arbitrated(uint256,(address,uint64,address,uint64,address,uint256,uint64,address,uint16,int16[2],uint16[4],uint256),uint256,uint256[5])": {
        "details": "Emitted when the arbitrator has resolved a dispute",
        "params": {
          "amounts": "All amounts (i.e. incl. marketplace fee, arbitrator fee, and protocol fee) in the token",
          "blockTime": "Timestamp of the block in which the transaction was minuted",
          "escrow": "The escrow data, incl. the final split between buyer and seller as decided by the arbitrator",
          "escrowId": "Id of the arbitrated escrow"
        }
      },
      "ArbitratorApproved(uint256,address,uint256)": {
        "details": "Emitted when the arbitrator proposal was approved by the other party",
        "params": {
          "arbitrator": "Arbitrator's address",
          "arbitratorFee": "Proposed fee in bips",
          "escrowId": "Id of the escrow to which the proposer belongs"
        }
      },
      "ArbitratorProposed(uint256,address,uint16,address)": {
        "details": "Emitted when an arbitrator has been proposed by one of the parties orif the other party sends a different proposal or also if the original party changes their proposal",
        "params": {
          "arbitrator": "Arbitrator's address",
          "arbitratorFee": "Proposed fee in bips",
          "escrowId": "Id of the escrow to which the proposer belongs",
          "proposer": "Address of the party that sent the proposal"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "approveArbitrator(uint256,address,uint16)": {
        "details": "To ensure the user approves an arbitrator they wanted, it requires the same parameters as proposal",
        "params": {
          "escrowId": "Id of an escrow",
          "validation": "Arbitrator's Fee - will be compared with the existing proposal",
          "validationAddress": "Arbitrator's address - will be compared with the existing proposal"
        }
      },
      "arbitrate(uint256,uint16[2])": {
        "params": {
          "escrowId": "Id of an escrow",
          "newSplit": "How the payment should be split between buyer [0] and seller [1]. [100, 0] will refund the payment to the buyer, [0, 100] will release it to the seller, anything in between will"
        }
      },
      "arbitrationCalculation(uint16[5])": {
        "details": "Calculates final splits of all parties involved in the payment when the paymet is decided by an arbitrator.If seller's split is < 100% it will discount the marketplace and protocol fee, but (unlike when refunded byseller or settled mutually) will keep full Arbitrator fee and deduct it from both shares proportionally",
        "params": {
          "currentSplit": "Current split in bips. See WHO_* contants for keys"
        },
        "returns": {
          "_0": "Splits in bips using the same keys for the array"
        }
      },
      "constructor": {
        "params": {
          "unicrowClaim_": "UnicrowClaim contract address",
          "unicrow_": "Unicrow contract address"
        }
      },
      "getArbitratorData(uint256)": {
        "details": "buyerConsensus and sellerConsensus indicate if the arbitrator was only proposed by one of the parties orhas been assigned by the mutual consensus",
        "params": {
          "escrowId": "ID of the escrow"
        },
        "returns": {
          "_0": "Arbitrator information."
        }
      },
      "proposeArbitrator(uint256,address,uint16)": {
        "params": {
          "arbitrator": "Arbitrator's address",
          "arbitratorFee": "Arbitrator fee in bips (can be 0)",
          "escrowId": "Id of the escrow"
        }
      },
      "setArbitrator(uint256,address,uint16)": {
        "details": "Called by Unicrow.pay()",
        "params": {
          "arbitrator": "Arbitrator's address",
          "arbitratorFee": "Arbitrator fee in bips (can be 0)",
          "escrowId": "Id of the escrow"
        }
      }
    },
    "title": "Unicrow Arbitrator",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "approveArbitrator(uint256,address,uint16)": {
        "notice": "Approve an arbitrator proposed by another party (i.e. by seller if buyer proposed, by buyer if seller proposed)."
      },
      "arbitrate(uint256,uint16[2])": {
        "notice": "Arbitrate an payment - to be called only by an escrow's arbitrator"
      },
      "constructor": {
        "notice": "The constructor provides immutable reference to the main escrow and claimMultiple contracts"
      },
      "escrowArbitrator(uint256)": {
        "notice": "Stores information about arbitrators in relation to escrows"
      },
      "getArbitratorData(uint256)": {
        "notice": "Get information about proposed or assigned arbitrator."
      },
      "proposeArbitrator(uint256,address,uint16)": {
        "notice": "One of the parties (buyer or seller) can call this to propose an arbitrator for an escrow that has no arbitrator defined"
      },
      "setArbitrator(uint256,address,uint16)": {
        "notice": "Assigns an arbitrator to an escrow."
      },
      "unicrow()": {
        "notice": "Reference to the main Unicrow contract"
      },
      "unicrowClaim()": {
        "notice": "Reference to the contract that manages claims from the escrows"
      }
    },
    "notice": "Functionality for assigning an arbitrator to an escrow and for an arbitrator to decide a dispute",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 10,
        "contract": "contracts/UnicrowArbitrator.sol:UnicrowArbitrator",
        "label": "_status",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 2544,
        "contract": "contracts/UnicrowArbitrator.sol:UnicrowArbitrator",
        "label": "escrowArbitrator",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint256,t_struct(Arbitrator)4910_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_uint256,t_struct(Arbitrator)4910_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct Arbitrator)",
        "numberOfBytes": "32",
        "value": "t_struct(Arbitrator)4910_storage"
      },
      "t_struct(Arbitrator)4910_storage": {
        "encoding": "inplace",
        "label": "struct Arbitrator",
        "members": [
          {
            "astId": 4897,
            "contract": "contracts/UnicrowArbitrator.sol:UnicrowArbitrator",
            "label": "arbitrator",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 4900,
            "contract": "contracts/UnicrowArbitrator.sol:UnicrowArbitrator",
            "label": "arbitratorFee",
            "offset": 20,
            "slot": "0",
            "type": "t_uint16"
          },
          {
            "astId": 4903,
            "contract": "contracts/UnicrowArbitrator.sol:UnicrowArbitrator",
            "label": "sellerConsensus",
            "offset": 22,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 4906,
            "contract": "contracts/UnicrowArbitrator.sol:UnicrowArbitrator",
            "label": "buyerConsensus",
            "offset": 23,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 4909,
            "contract": "contracts/UnicrowArbitrator.sol:UnicrowArbitrator",
            "label": "arbitrated",
            "offset": 24,
            "slot": "0",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint16": {
        "encoding": "inplace",
        "label": "uint16",
        "numberOfBytes": "2"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}