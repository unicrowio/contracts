{
  "address": "0xdDfDCa767F9143B804740aFA8087A286E087dF13",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "unicrow_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "unicrowArbitrator_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "protocolFeeAddress_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "escrowId",
              "type": "uint256"
            },
            {
              "internalType": "uint256[5]",
              "name": "amount",
              "type": "uint256[5]"
            }
          ],
          "indexed": false,
          "internalType": "struct UnicrowClaim.ClaimEvent[]",
          "name": "escrows",
          "type": "tuple[]"
        }
      ],
      "name": "Claim",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "escrowId",
              "type": "uint256"
            },
            {
              "internalType": "uint256[5]",
              "name": "amount",
              "type": "uint256[5]"
            }
          ],
          "indexed": false,
          "internalType": "struct UnicrowClaim.ClaimEvent",
          "name": "escrow",
          "type": "tuple"
        }
      ],
      "name": "SingleClaim",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "escrowId",
          "type": "uint256"
        }
      ],
      "name": "claim",
      "outputs": [
        {
          "internalType": "uint256[5]",
          "name": "",
          "type": "uint256[5]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "escrows",
          "type": "uint256[]"
        }
      ],
      "name": "claimMultiple",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "crowRewards",
      "outputs": [
        {
          "internalType": "contract IUnicrowClaimRewards",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "protocolFeeAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "stakingRewards",
      "outputs": [
        {
          "internalType": "contract IUnicrowStakingRewards",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unicrow",
      "outputs": [
        {
          "internalType": "contract Unicrow",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unicrowArbitrator",
      "outputs": [
        {
          "internalType": "contract UnicrowArbitrator",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "crowRewards_",
          "type": "address"
        }
      ],
      "name": "updateCrowRewards",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "protocolFeeAddress_",
          "type": "address"
        }
      ],
      "name": "updateProtocolFeeAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "stakingRewards_",
          "type": "address"
        }
      ],
      "name": "updateStakingRewards",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x07cf163f365ebe5222879e8bb2cfd14b78ccb19d5da83cc4cfbb5fcbb7225ca8",
  "receipt": {
    "to": "0xa5De8d8212E484B8C5B7C5Ea98C3e5f111538613",
    "from": "0x7FAa90b44af62407CE4a29BFe4A5Da2282584214",
    "contractAddress": "0xdDfDCa767F9143B804740aFA8087A286E087dF13",
    "transactionIndex": 2,
    "gasUsed": "8186955",
    "logsBloom": "0x00000000400000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000040000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000800000000000000000000000000080000004000000000000000000400000000000000000004000000000000000000000000000000000000000000000000000000000000820000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xd02e655ae0e844c05fe4cab8bcd7a0e3db920e3c8d0ef3b7f4df23d5cfbc2ce2",
    "transactionHash": "0x07cf163f365ebe5222879e8bb2cfd14b78ccb19d5da83cc4cfbb5fcbb7225ca8",
    "logs": [
      {
        "transactionIndex": 2,
        "blockNumber": 46137707,
        "transactionHash": "0x07cf163f365ebe5222879e8bb2cfd14b78ccb19d5da83cc4cfbb5fcbb7225ca8",
        "address": "0xa5De8d8212E484B8C5B7C5Ea98C3e5f111538613",
        "topics": [
          "0x66753cd2356569ee081232e3be8909b950e0a76c1f8460c3a5e3c2be32b11bed"
        ],
        "data": "0x0000000000000000000000007cbb62eaa69f79e6873cd1ecb2392971036cfaa4000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000082864000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000001e800000000000000000000000000000000000000000000000000000000000001c644c8c9ea1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000001bf660c06040523480156200001157600080fd5b5060405162001b9638038062001b96833981016040819052620000349162000097565b6001600055606092831b6001600160601b03199081166080529190921b1660a052600380546001600160a01b0319166001600160a01b03909216919091179055620000e1565b80516001600160a01b03811681146200009257600080fd5b919050565b600080600060608486031215620000ad57600080fd5b620000b8846200007a565b9250620000c8602085016200007a565b9150620000d8604085016200007a565b90509250925092565b60805160601c60a05160601c611a3d620001596000396000818160f10152818161032f015281816109000152610ed80152600081816101580152818161026f015281816106ac0152818161084501528181610cd801528181610db5015281816110070152818161125301526112e40152611a3d6000f3fe608060405234801561001057600080fd5b50600436106100be5760003560e01c80639051cce911610076578063a76b8fb71161005b578063a76b8fb7146101a0578063cce516b7146101b3578063eeca9a31146101c657600080fd5b80639051cce91461017a57806394417bce1461018d57600080fd5b80634cb6995a116100a75780634cb6995a1461012b57806364b87a70146101405780636e4e29341461015357600080fd5b8063379607f5146100c357806349c4920f146100ec575b600080fd5b6100d66100d1366004611814565b6101d9565b6040516100e391906118f4565b60405180910390f35b6101137f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100e3565b61013e610139366004611566565b6106aa565b005b600254610113906001600160a01b031681565b6101137f000000000000000000000000000000000000000000000000000000000000000081565b61013e61018836600461162a565b610787565b600154610113906001600160a01b031681565b61013e6101ae366004611566565b610cd6565b600354610113906001600160a01b031681565b61013e6101d4366004611566565b610db3565b6101e16113d8565b600260005414156102395760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064015b60405180910390fd5b600260009081556040517f7d19e596000000000000000000000000000000000000000000000000000000008152600481018490527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690637d19e596906024016102006040518083038186803b1580156102ba57600080fd5b505afa1580156102ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f2919061172f565b6040517f16e0551b000000000000000000000000000000000000000000000000000000008152600481018590529091506000906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906316e0551b9060240160a06040518083038186803b15801561037157600080fd5b505afa158015610385573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103a9919061169f565b905081610100015161ffff166000146103ec5760405162461bcd60e51b8152602060048201526005602482015264302d30303560d81b6044820152606401610230565b61012082015160200151600190810b12801590610413575061012082015151600190810b12155b8061042b57508160c0015167ffffffffffffffff1642115b61045f5760405162461bcd60e51b8152602060048201526005602482015264181698181b60d91b6044820152606401610230565b600061046b8284610e90565b9050600061047e8461016001518361113c565b6040805160a08101825286516001600160a01b0390811682528783015181166020830152608080890151821693830193909352600354811660608301528651169181019190915260e0860151919250906104dd90889084908490611224565b6001546001600160a01b0316158015906104fa5750606082015115155b156105835760015460e0860151865160408089015160608701519151631d9dc2a760e21b81526001600160a01b03948516600482015292841660248401528316604483015260648201529116906376770a9c90608401600060405180830381600087803b15801561056a57600080fd5b505af115801561057e573d6000803e3d6000fd5b505050505b6002546001600160a01b0316158015906105a05750606082015115155b156106165760025460e08601516060840151604051630bb03fdb60e21b81526001600160a01b0392831660048201526024810191909152911690632ec0ff6c90604401600060405180830381600087803b1580156105fd57600080fd5b505af1158015610611573d6000803e3d6000fd5b505050505b7f4dcc1cbd3586ce0ab63396e3e3601351a6fd799aec0cd7bd65761110335335606040518060400160405280898152602001848152506040516106599190611902565b60405180910390a1506040805160a081018252825181526020808401519082015282820151918101919091526060808301519082015260809182015191810191909152600160005595945050505050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663795053d36040518163ffffffff1660e01b815260040160206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b919061158a565b6001600160a01b0316336001600160a01b03161461075857600080fd5b6003805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b600260005414156107da5760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610230565b600260009081558167ffffffffffffffff8111156107fa576107fa6119d9565b60405190808252806020026020018201604052801561083357816020015b6108206113f6565b8152602001906001900390816108185790505b50905060005b82811015610c945760007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316637d19e596868685818110610884576108846119c3565b905060200201356040518263ffffffff1660e01b81526004016108a991815260200190565b6102006040518083038186803b1580156108c257600080fd5b505afa1580156108d6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108fa919061172f565b905060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166316e0551b87878681811061093f5761093f6119c3565b905060200201356040518263ffffffff1660e01b815260040161096491815260200190565b60a06040518083038186803b15801561097c57600080fd5b505afa158015610990573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b4919061169f565b905081610100015161ffff166000146109f75760405162461bcd60e51b8152602060048201526005602482015264302d30303560d81b6044820152606401610230565b61012082015160200151600190810b12801590610a1e575061012082015151600190810b12155b80610a3657508160c0015167ffffffffffffffff1642115b610a6a5760405162461bcd60e51b8152602060048201526005602482015264181698181b60d91b6044820152606401610230565b6000610a768284610e90565b90506000610a898461016001518361113c565b6040805160a08101825286516001600160a01b03908116825287830151811660208301526080808901518216938301939093526003548116606083015286511691810191909152909150610afb898988818110610ae857610ae86119c3565b9050602002013583838860e00151611224565b6001546001600160a01b031615801590610b185750606082015115155b15610ba15760015460e0860151865160408089015160608701519151631d9dc2a760e21b81526001600160a01b03948516600482015292841660248401528316604483015260648201529116906376770a9c90608401600060405180830381600087803b158015610b8857600080fd5b505af1158015610b9c573d6000803e3d6000fd5b505050505b6002546001600160a01b031615801590610bbe5750606082015115155b15610c345760025460e08601516060840151604051630bb03fdb60e21b81526001600160a01b0392831660048201526024810191909152911690632ec0ff6c90604401600060405180830381600087803b158015610c1b57600080fd5b505af1158015610c2f573d6000803e3d6000fd5b505050505b60405180604001604052808a8a89818110610c5157610c516119c3565b90506020020135815260200183815250878781518110610c7357610c736119c3565b6020026020010181905250505050505080610c8d90611992565b9050610839565b507f05270dc3f040b6099aa59b4dc25043ad9d14706a809c4dd4ad6356935332b85181604051610cc49190611871565b60405180910390a15050600160005550565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663795053d36040518163ffffffff1660e01b815260040160206040518083038186803b158015610d2f57600080fd5b505afa158015610d43573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d67919061158a565b6001600160a01b0316336001600160a01b031614610d8457600080fd5b6001805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663795053d36040518163ffffffff1660e01b815260040160206040518083038186803b158015610e0c57600080fd5b505afa158015610e20573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e44919061158a565b6001600160a01b0316336001600160a01b031614610e6157600080fd5b6002805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b610e986113d8565b610ea06113d8565b600084606001518015610eb4575084604001515b9050600081610ec4576000610eca565b85602001515b9050856080015115611005577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316634c403c536040518060a00160405280886101400151600060ff1660048110610f2b57610f2b6119c3565b6020908102919091015161ffff90811683526101408b018051830151821692840192909252815160409081015182168185015291516060908101518216908401528616608090920191909152517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b168152610fae91906004016118bf565b60a06040518083038186803b158015610fc657600080fd5b505afa158015610fda573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ffe91906115a7565b9250611130565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663d02f411e6040518060a00160405280886101400151600060ff166004811061105a5761105a6119c3565b6020908102919091015161ffff90811683526101408b018051830151821692840192909252815160409081015182168185015291516060908101518216908401528616608090920191909152517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b1681526110dd91906004016118bf565b60a06040518083038186803b1580156110f557600080fd5b505afa158015611109573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061112d91906115a7565b92505b50909150505b92915050565b6111446113d8565b61114c6113d8565b82516127109061116190869061ffff1661195c565b61116b919061193a565b815260208301516127109061118590869061ffff1661195c565b61118f919061193a565b60208201526040830151612710906111ac90869061ffff1661195c565b6111b6919061193a565b60408201526080830151612710906111d390869061ffff1661195c565b6111dd919061193a565b608082018190526040820151602083015183516111fa908861197b565b611204919061197b565b61120e919061197b565b611218919061197b565b60608201529392505050565b6040517fe7aa0bd7000000000000000000000000000000000000000000000000000000008152600481018590527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063e7aa0bd790602401600060405180830381600087803b15801561129f57600080fd5b505af11580156112b3573d6000803e3d6000fd5b5050505060005b60058110156113d15760008482600581106112d7576112d76119c3565b602002015111156113c1577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638ede1f05848360058110611323576113236119c3565b602002015186846005811061133a5761133a6119c3565b60200201516040517fffffffff0000000000000000000000000000000000000000000000000000000060e085901b1681526001600160a01b03928316600482015260248101919091529085166044820152606401600060405180830381600087803b1580156113a857600080fd5b505af11580156113bc573d6000803e3d6000fd5b505050505b6113ca81611992565b90506112ba565b5050505050565b6040518060a001604052806005906020820280368337509192915050565b6040518060400160405280600081526020016114106113d8565b905290565b8051611420816119ef565b919050565b600082601f83011261143657600080fd5b6040516040810181811067ffffffffffffffff82111715611459576114596119d9565b806040525080838560408601111561147057600080fd5b6000805b60028110156114a25782518060010b811461148d578283fd5b84526020938401939290920191600101611474565b50929695505050505050565b600082601f8301126114bf57600080fd5b6040516080810181811067ffffffffffffffff821117156114e2576114e26119d9565b6040528083608081018610156114f757600080fd5b60005b60048110156115215761150c8261153c565b835260209283019291909101906001016114fa565b509195945050505050565b8051801515811461142057600080fd5b805161ffff8116811461142057600080fd5b805167ffffffffffffffff8116811461142057600080fd5b60006020828403121561157857600080fd5b8135611583816119ef565b9392505050565b60006020828403121561159c57600080fd5b8151611583816119ef565b600060a082840312156115b957600080fd5b82601f8301126115c857600080fd5b60405160a0810181811067ffffffffffffffff821117156115eb576115eb6119d9565b604052808360a0810186101561160057600080fd5b60005b6005811015611521576116158261153c565b83526020928301929190910190600101611603565b6000806020838503121561163d57600080fd5b823567ffffffffffffffff8082111561165557600080fd5b818501915085601f83011261166957600080fd5b81358181111561167857600080fd5b8660208260051b850101111561168d57600080fd5b60209290920196919550909350505050565b600060a082840312156116b157600080fd5b60405160a0810181811067ffffffffffffffff821117156116d4576116d46119d9565b60405282516116e2816119ef565b81526116f06020840161153c565b60208201526117016040840161152c565b60408201526117126060840161152c565b60608201526117236080840161152c565b60808201529392505050565b6000610200828403121561174257600080fd5b61174a611910565b61175383611415565b81526117616020840161154e565b602082015261177260408401611415565b60408201526117836060840161154e565b606082015261179460808401611415565b608082015260a083015160a08201526117af60c0840161154e565b60c08201526117c060e08401611415565b60e08201526101006117d381850161153c565b908201526101206117e685858301611425565b908201526101606117f9858583016114ae565b6101408301526101e084015181830152508091505092915050565b60006020828403121561182657600080fd5b5035919050565b8060005b6005811015611850578151845260209384019390910190600101611831565b50505050565b80518252602081015161186c602084018261182d565b505050565b6020808252825182820181905260009190848201906040850190845b818110156118b3576118a0838551611856565b9284019260c0929092019160010161188d565b50909695505050505050565b60a08101818360005b60058110156118eb57815161ffff168352602092830192909101906001016118c8565b50505092915050565b60a08101611136828461182d565b60c081016111368284611856565b604051610180810167ffffffffffffffff81118282101715611934576119346119d9565b60405290565b60008261195757634e487b7160e01b600052601260045260246000fd5b500490565b6000816000190483118215151615611976576119766119ad565b500290565b60008282101561198d5761198d6119ad565b500390565b60006000198214156119a6576119a66119ad565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b0381168114611a0457600080fd5b5056fea264697066735822122085515bdc3a8067067f4efc1330f48367e652e40831b9ee7f0e3881433c6080b264736f6c63430008070033000000000000000000000000fef5da5c801c137632d51d4ccec16e9a89a91dec0000000000000000000000006c3c223f8b5430b6e8d1bc2d2f2377503ac6ffb8000000000000000000000000a5de8d8212e484b8c5b7c5ea98c3e5f111538613000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000410000000000000000000000007faa90b44af62407ce4a29bfe4a5da228258421400000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000030000000000000000000000007faa90b44af62407ce4a29bfe4a5da22825842140000000000000000000000000000000000000000000000000000000000000001",
        "logIndex": 7,
        "blockHash": "0xd02e655ae0e844c05fe4cab8bcd7a0e3db920e3c8d0ef3b7f4df23d5cfbc2ce2"
      },
      {
        "transactionIndex": 2,
        "blockNumber": 46137707,
        "transactionHash": "0x07cf163f365ebe5222879e8bb2cfd14b78ccb19d5da83cc4cfbb5fcbb7225ca8",
        "address": "0xa5De8d8212E484B8C5B7C5Ea98C3e5f111538613",
        "topics": [
          "0x4db17dd5e4732fb6da34a148104a592783ca119a1e7bb8829eba6cbadef0b511"
        ],
        "data": "0x000000000000000000000000ddfdca767f9143b804740afa8087a286e087df13",
        "logIndex": 8,
        "blockHash": "0xd02e655ae0e844c05fe4cab8bcd7a0e3db920e3c8d0ef3b7f4df23d5cfbc2ce2"
      },
      {
        "transactionIndex": 2,
        "blockNumber": 46137707,
        "transactionHash": "0x07cf163f365ebe5222879e8bb2cfd14b78ccb19d5da83cc4cfbb5fcbb7225ca8",
        "address": "0xa5De8d8212E484B8C5B7C5Ea98C3e5f111538613",
        "topics": [
          "0x442e715f626346e8c54381002da614f62bee8d27386535b2521ec8540898556e"
        ],
        "data": "0x67c65696180607ad61b5c68cb955d80294e43692a76257b335cffa23930ceb800000000000000000000000000000000000000000000000000000000000000000",
        "logIndex": 9,
        "blockHash": "0xd02e655ae0e844c05fe4cab8bcd7a0e3db920e3c8d0ef3b7f4df23d5cfbc2ce2"
      }
    ],
    "blockNumber": 46137707,
    "cumulativeGasUsed": "9421102",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xFEf5DA5c801c137632D51d4ccec16e9a89A91deC",
    "0x6c3c223F8b5430b6E8D1bC2D2F2377503AC6Ffb8",
    "0xa5De8d8212E484B8C5B7C5Ea98C3e5f111538613"
  ],
  "numDeployments": 1,
  "solcInputHash": "dd06e32b55195a1ed654e198c4426365",
  "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"unicrow_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"unicrowArbitrator_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"protocolFeeAddress_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"escrowId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[5]\",\"name\":\"amount\",\"type\":\"uint256[5]\"}],\"indexed\":false,\"internalType\":\"struct UnicrowClaim.ClaimEvent[]\",\"name\":\"escrows\",\"type\":\"tuple[]\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"escrowId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[5]\",\"name\":\"amount\",\"type\":\"uint256[5]\"}],\"indexed\":false,\"internalType\":\"struct UnicrowClaim.ClaimEvent\",\"name\":\"escrow\",\"type\":\"tuple\"}],\"name\":\"SingleClaim\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"escrowId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"\",\"type\":\"uint256[5]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"escrows\",\"type\":\"uint256[]\"}],\"name\":\"claimMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crowRewards\",\"outputs\":[{\"internalType\":\"contract IUnicrowClaimRewards\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingRewards\",\"outputs\":[{\"internalType\":\"contract IUnicrowStakingRewards\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unicrow\",\"outputs\":[{\"internalType\":\"contract Unicrow\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unicrowArbitrator\",\"outputs\":[{\"internalType\":\"contract UnicrowArbitrator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"crowRewards_\",\"type\":\"address\"}],\"name\":\"updateCrowRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"protocolFeeAddress_\",\"type\":\"address\"}],\"name\":\"updateProtocolFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakingRewards_\",\"type\":\"address\"}],\"name\":\"updateStakingRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"Claim((uint256,uint256[5])[])\":{\"params\":{\"escrows\":\"data of all escrows that were claimed\"}},\"SingleClaim((uint256,uint256[5]))\":{\"params\":{\"escrow\":\"data of the claimed escrow\"}}},\"kind\":\"dev\",\"methods\":{\"claim(uint256)\":{\"details\":\"To save everyone's gas costs, it claims balances and fees of all parties that are eligible for a share from the escrow\",\"params\":{\"escrowId\":\"escrow to be claimed\"}},\"claimMultiple(uint256[])\":{\"details\":\"To save everyone's gas costs, it claims balances and fees of all parties that are eligible for a share from the escrow\",\"params\":{\"escrows\":\"List of escrows to be claimed.\"}},\"constructor\":{\"params\":{\"protocolFeeAddress_\":\"address to collect protocol fee\",\"unicrowArbitrator_\":\"arbitration contract\",\"unicrow_\":\"main escrow contract\"}}},\"title\":\"Contract for managing claims from Unicrow's escrow\",\"version\":1},\"userdoc\":{\"events\":{\"Claim((uint256,uint256[5])[])\":{\"notice\":\"Emitted when multiple escrows are claimed\"},\"SingleClaim((uint256,uint256[5]))\":{\"notice\":\"Emitted when a single escrow payment is claimed\"}},\"kind\":\"user\",\"methods\":{\"claim(uint256)\":{\"notice\":\"Claim a single escrow\"},\"claimMultiple(uint256[])\":{\"notice\":\"Claim multiple escrows.\"},\"protocolFeeAddress()\":{\"notice\":\"Destination address of the protocol fee (governed)\"},\"unicrow()\":{\"notice\":\"Reference to the main escrow contract (immutable)\"},\"unicrowArbitrator()\":{\"notice\":\"Reference to the Arbitrator contract (immutable)\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/UnicrowClaim.sol\":\"UnicrowClaim\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/security/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x0e9621f60b2faabe65549f7ed0f24e8853a45c1b7990d47e8160e523683f3935\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0xe0c8b625a79bac0fe80f17cfb521e072805cc9cef1c96a5caf45b264e74812fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc3d946432c0ddbb1f846a0d3985be71299df331b91d06732152117f62f0be2b5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ccf9d2313a313d41a791505f2b5abfdc62191b5d4334f7f7a82691c088a1c87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Counters.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\",\"keccak256\":\"0xf0018c2440fbe238dd3a8732fa8e17a0f9dce84d31451dc8a32f6d62b349c9f1\",\"license\":\"MIT\"},\"contracts/Unicrow.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./interfaces/IUnicrow.sol\\\";\\nimport \\\"./interfaces/IUnicrowClaim.sol\\\";\\nimport \\\"./interfaces/IUnicrowArbitrator.sol\\\";\\nimport \\\"./UnicrowDispute.sol\\\";\\nimport \\\"./UnicrowTypes.sol\\\";\\n\\n/// @title The primary Unicrow contract\\n/// @notice Receives and distributes the payments, maintains and provides information about the escrow records, and allows basic operations\\ncontract Unicrow is ReentrancyGuard, IUnicrow, Context {\\n    using Counters for Counters.Counter;\\n\\n    /// Generates unique escrow ID in incremental order\\n    Counters.Counter public escrowIdCounter;\\n\\n    /// @notice Arbitrator information and functionality for the escrows\\n    IUnicrowArbitrator public immutable unicrowArbitrator;\\n\\n    /// @notice Withdraws payments from the escrows once the criteria are met\\n    IUnicrowClaim public immutable unicrowClaim;\\n\\n    /// @notice Dispute resolution, incl. challenges and settlements\\n    UnicrowDispute public immutable unicrowDispute;\\n\\n    /// @notice Escrow fee in bips (can never be higher than 100)\\n    uint16 public protocolFee;\\n\\n    /// address of a governance contract (multisig initially, DAO governor eventually)\\n    address public governanceAddress;\\n\\n    /// storage of the primary escrow data. The key is generated by the contract incrementally\\n    mapping(uint256 => Escrow) escrows;\\n\\n    /**\\n     * @notice Emitted when the payment is deposited into the contract and an escrow record is created\\n     * @param escrowId Unique, contract-generated escrow record identifier\\n     * @param blockTime timestamp of the block in which the transaction was included\\n     * @param escrow Details of the escrow as stored in the contract\\n     * @param arbitrator Address of an arbitrator (zero is returned if no arbitrator was defined)\\n     * @param arbitratorFee Arbitrator's fee in bips\\n     * @param challengePeriod Initial challenge period in seconds\\n     */\\n    event Pay(uint256 indexed escrowId, uint256 blockTime, Escrow escrow, address arbitrator, uint256 arbitratorFee, uint256 challengePeriod);\\n\\n    /**\\n     * @notice Emitted when the buyer releases the payment manually (regardless of the challenge period)\\n     * @param escrowId ID of the released escrow payment\\n     * @param blockTime Timestamp of the block in which the transaction was included\\n     * @param escrow Details of the released Escrow\\n     * @param amounts Amounts in token allocated to each party (incl. fees). See UnicrowTypes for mapping of each party (WHO_*)\\n     */\\n    event Release(uint256 indexed escrowId, uint256 blockTime, Escrow escrow, uint256[5] amounts);\\n\\n    /**\\n     * @notice Emitted when seller fully refunds the payment. Detailed calculated values are not returned because the payment is refunded in full, all fees are waived\\n     * @param escrowId Id of the refunded payment\\n     * @param escrow Details of the refunded payment\\n     * @param blockTime Timestamp of the block in which the transaction was included\\n     */\\n    event Refund(uint256 indexed escrowId, Escrow escrow, uint256 blockTime);\\n\\n    /// The contructor initiates immutable and governed references to other contracts\\n    constructor(\\n        address unicrowClaim_,\\n        address unicrowArbitrator_,\\n        address unicrowDispute_,\\n        address governanceAddress_,\\n        uint16 protocolFee_\\n    ) {\\n        unicrowArbitrator = IUnicrowArbitrator(unicrowArbitrator_);\\n        unicrowClaim = IUnicrowClaim(unicrowClaim_);\\n        unicrowDispute = UnicrowDispute(unicrowDispute_);\\n        governanceAddress = governanceAddress_;\\n        protocolFee = protocolFee_;\\n    }\\n\\n    /// Check that the governance contract is calling this\\n    modifier onlyGovernance() {\\n        require(_msgSender() == governanceAddress);\\n        _;\\n    }\\n\\n    /// Check that Unicrow's claimMultiple contract is calling this\\n    modifier onlyUnicrowClaim() {\\n        require(_msgSender() == address(unicrowClaim));\\n        _;\\n    }\\n\\n    /// Check that arbitration or dispute contract is calling this\\n    modifier onlyUnicrowArbitratorOrDispute() {\\n        require(_msgSender() == address(unicrowArbitrator) || _msgSender() == address(unicrowDispute));\\n        _;\\n    }\\n\\n    /// Check that dispute contract is calling this\\n    modifier onlyUnicrowDispute() {\\n        require(_msgSender() == address(unicrowDispute));\\n        _;\\n    }\\n\\n    /// @inheritdoc IUnicrow\\n    function pay(\\n        EscrowInput calldata input,\\n        address arbitrator,\\n        uint16 arbitratorFee\\n    ) external override payable nonReentrant {\\n        // Get current escrow id from the incremental counter\\n        uint256 escrowId = escrowIdCounter.current();\\n\\n        // The address that sent the payment is set as a buyer\\n        address buyer = _msgSender();\\n\\n        // Amount of the payment in ERC20 tokens\\n        uint amount = input.amount;\\n\\n        // Make sure there's something left for the seller :-)\\n        require(arbitratorFee + input.marketplaceFee + protocolFee < 10000, \\\"1-026\\\");\\n\\n        // Payment can't use address(0)\\n        require(escrows[escrowId].buyer == address(0), \\\"0-001\\\");\\n\\n        // Seller cannot be empty\\n        require(input.seller != address(0), \\\"0-002\\\");\\n\\n        // Buyer cannot be seller\\n        require(buyer != input.seller, \\\"0-003\\\");\\n\\n        // Payment amount must be greater than zero\\n        require(amount > 0, \\\"0-011\\\");\\n\\n        // Buyer can't send ETH if currency is not ETH\\n        if(msg.value > 0) {\\n            require(input.currency == address(0), \\\"0-010\\\");\\n        }\\n        \\n        // Check if the payment was made in ETH \\n        if (input.currency == address(0)) {\\n            // Amount in the payment metadata must match what was sent\\n            require(amount == msg.value);\\n        } else {\\n            uint balanceBefore = IERC20(input.currency).balanceOf(address(this));\\n\\n            // If the payment was made in ERC20 and not ETH, execute the transfer\\n            SafeERC20.safeTransferFrom(\\n                IERC20(input.currency),\\n                buyer,\\n                address(this),\\n                amount\\n            );\\n\\n            uint balanceAfter = IERC20(input.currency).balanceOf(address(this));\\n\\n            // Make sure that the input amount is the amount received\\n            amount = balanceAfter - balanceBefore;\\n        }\\n\\n        // If a marketplace fee was set, ensure a marketplace address was set\\n        if(input.marketplaceFee > 0) {\\n            require(input.marketplace != address(0), \\\"0-009\\\");\\n        }\\n\\n        // Check if the arbitrator was defined\\n        if (arbitrator != address(0)) {\\n\\n            // Arbitrator can't be seller or buyer\\n            require(arbitrator != buyer && arbitrator != input.seller, \\\"1-027\\\");\\n\\n            // Set the arbitrator in the arbitrator contract\\n            unicrowArbitrator.setArbitrator(escrowId, arbitrator, arbitratorFee);\\n        }\\n\\n        // Split array is how Unicrow maintains information about seller's and buyer's shares, and the fees\\n        uint16[4] memory split = [0, 10000, input.marketplaceFee, protocolFee];\\n        \\n        // Set initial consensus to buyer = 0, seller = 1\\n        int16[2] memory consensus = [int16(0), int16(1)];\\n\\n        // Create an Escrow object that will be stored in the contract\\n        Escrow memory escrow = Escrow({\\n            buyer: buyer,\\n            seller: input.seller,\\n            currency: input.currency,\\n            marketplace: input.marketplace,\\n            marketplaceFee: input.marketplaceFee,\\n            claimed: 0,\\n            split: split,\\n            consensus: consensus,\\n            challengeExtension: uint64(input.challengeExtension > 0 ? input.challengeExtension : input.challengePeriod),\\n            challengePeriodStart: uint64(block.timestamp), //challenge start\\n            challengePeriodEnd: uint64(block.timestamp + input.challengePeriod), //chalenge end\\n            amount: amount\\n        });\\n\\n        // Store the escrow information\\n        escrows[escrowId] = escrow;\\n\\n        // Increase the escrow id counter\\n        escrowIdCounter.increment();\\n\\n        emit Pay(escrowId, block.timestamp, escrow, arbitrator, arbitratorFee, input.challengePeriod);\\n    }\\n\\n    /// @inheritdoc IUnicrow\\n    function refund(uint256 escrowId) external override nonReentrant {\\n        address sender = _msgSender();\\n\\n        // Get escrow information from the contract's storage\\n        Escrow memory escrow = escrows[escrowId];\\n\\n        // Only seller can refund\\n        require(sender == escrow.seller, \\\"1-011\\\");\\n\\n        // Check that the escrow is not claimed yet\\n        require(escrow.claimed == 0, \\\"0-005\\\");\\n\\n        // Set split to 100% to buyer and waive the fees\\n        escrow.split[WHO_BUYER] = 10000;\\n        escrow.split[WHO_SELLER] = 0;\\n        escrow.split[WHO_MARKETPLACE] = 0;\\n        escrow.split[WHO_PROTOCOL] = 0;\\n        \\n        // Keep record of number of challenges (for reputation purposes)\\n        escrow.consensus[WHO_BUYER] = abs8(escrow.consensus[WHO_BUYER]) + 1;\\n\\n        // Set escrow consensus based on the number of previous challenges (1 = no challenge)\\n        escrow.consensus[WHO_SELLER] = abs8(escrow.consensus[WHO_SELLER]);\\n\\n        // Update splits and consensus information in the storage\\n        escrows[escrowId].split = escrow.split;\\n        escrows[escrowId].consensus = escrow.consensus;\\n\\n        // Update the escrow as claimed in the storage and in the emitted event\\n        escrows[escrowId].claimed = 1;\\n        escrow.claimed = 1;\\n\\n        // Withdraw the amount to the buyer\\n        if (address(escrow.currency) == address(0)) {\\n            (bool success, ) = escrow.buyer.call{value: escrow.amount}(\\\"\\\");\\n            require(success, \\\"1-012\\\");\\n        } else {\\n            SafeERC20.safeTransfer(\\n                IERC20(escrow.currency),\\n                escrow.buyer,\\n                escrow.amount\\n            );\\n        }\\n\\n\\n        emit Refund(escrowId, escrow, block.timestamp);\\n    }\\n\\n    /// @inheritdoc IUnicrow\\n    function release(uint256 escrowId) external override {\\n        address sender = _msgSender();\\n        Escrow memory escrow = escrows[escrowId];\\n\\n        // Only buyer can release\\n        require(sender == escrow.buyer, \\\"1-025\\\");\\n\\n        // Set buyer consensus to 1 or based on the number of previous challenges\\n        escrow.consensus[WHO_BUYER] = abs8(escrow.consensus[WHO_BUYER]) + 1;\\n\\n        // Set seller's escrow consensus based on the number of previous challenges\\n        escrow.consensus[WHO_SELLER] = abs8(escrow.consensus[WHO_SELLER]);\\n\\n        // Update consensus in the storage\\n        escrows[escrowId].consensus = escrow.consensus;\\n\\n        // Claim the payment and fees and get the final amounts\\n        uint256[5] memory amounts = unicrowClaim.claim(escrowId);\\n\\n        // Emit all the information including the amounts\\n        emit Release(escrowId, block.timestamp, escrow, amounts);\\n    }\\n\\n    /// @inheritdoc IUnicrow\\n    function challenge(\\n        uint256 escrowId,\\n        uint16[4] calldata split,\\n        int16[2] calldata consensus,\\n        uint64 challengeStart,\\n        uint64 challengeEnd\\n    ) external override onlyUnicrowDispute {\\n        escrows[escrowId].split = split;\\n        escrows[escrowId].consensus = consensus;\\n        escrows[escrowId].challengePeriodStart = challengeStart;\\n        escrows[escrowId].challengePeriodEnd = challengeEnd;\\n    }\\n\\n    /// @inheritdoc IUnicrow\\n    function updateEscrowFee(uint16 fee) external override onlyGovernance {\\n        require(fee <= 100, \\\"0-008\\\");\\n        protocolFee = fee;\\n    }\\n\\n    /// @inheritdoc IUnicrow\\n    function updateGovernance(address governance) external override onlyGovernance {\\n        governanceAddress = governance;\\n    }\\n\\n    /// @notice Return basic escrow information (excl. arbitration information, settlement offers, and token details)\\n    /// @param escrowId ID of the escrow to be returned\\n    function getEscrow(uint256 escrowId)\\n        external\\n        override\\n        view\\n        returns (Escrow memory)\\n    {\\n        return escrows[escrowId];\\n    }\\n\\n    /// @notice Return all the escrow data (incl. arbitration information, settlement offers, and token details)\\n    /// @param escrowId ID of the escrow to be returned\\n    function getAllEscrowData(uint256 escrowId)\\n        external\\n        view\\n        returns (Data memory)\\n    {\\n        address currency = escrows[escrowId].currency;\\n\\n        // Get information about the ERC20 token (or return ETH)\\n        Token memory token = Token({\\n            address_: currency,\\n            decimals: currency == address(0) ? 18 : ERC20(currency).decimals(),\\n            symbol: currency == address(0) ? \\\"ETH\\\" : ERC20(currency).symbol()\\n        });\\n\\n        Arbitrator memory arbitrator = unicrowArbitrator.getArbitratorData(escrowId);\\n        Settlement memory settlement = unicrowDispute.getSettlementDetails(escrowId);\\n\\n        return Data(\\n            escrows[escrowId],\\n            arbitrator,\\n            settlement,\\n            token\\n        );\\n    }\\n\\n    /// @dev Transfer ether or token from this contract's treasury. Can be called only by Unicrow's Claim contract\\n    function sendEscrowShare(\\n        address to,\\n        uint256 amount,\\n        address currency\\n    ) public onlyUnicrowClaim {\\n         if(currency == address(0)) {\\n            to.call{value: amount, gas: 5000}(\\\"\\\");\\n         } else {\\n           SafeERC20.safeTransfer(\\n                IERC20(currency),\\n                to,\\n                amount\\n            );\\n         }\\n     }\\n\\n    /// @inheritdoc IUnicrow\\n    function settle(\\n        uint256 escrowId,\\n        uint16[4] calldata split,\\n        int16[2] calldata consensus\\n    ) external override onlyUnicrowArbitratorOrDispute {\\n        escrows[escrowId].split = split;\\n        escrows[escrowId].consensus = consensus;\\n    }\\n\\n    /// @inheritdoc IUnicrow\\n    function splitCalculation(\\n        uint16[5] calldata currentSplit\\n    ) external pure override returns (uint16[5] memory) {\\n        uint16[5] memory split;\\n\\n        uint16 calculatedArbitratorFee;\\n\\n        // Discount the protocol fee based on seller's share\\n        if (currentSplit[WHO_PROTOCOL] > 0) {\\n            split[WHO_PROTOCOL] = uint16((\\n                uint256(currentSplit[WHO_PROTOCOL]) *\\n                    currentSplit[WHO_SELLER]) /\\n                    _100_PCT_IN_BIPS\\n            );\\n        }\\n\\n        // Discount the marketplace fee based on the seller's share\\n        if (currentSplit[WHO_MARKETPLACE] > 0) {\\n            split[WHO_MARKETPLACE] = uint16(\\n                (uint256(currentSplit[WHO_MARKETPLACE]) *\\n                    currentSplit[WHO_SELLER]) /\\n                    _100_PCT_IN_BIPS\\n            );\\n        }\\n\\n        // Calculate the arbitrator fee based on the seller's split\\n        if (currentSplit[WHO_ARBITRATOR] > 0) {\\n            calculatedArbitratorFee = uint16(\\n                (uint256(currentSplit[WHO_ARBITRATOR]) *\\n                    currentSplit[WHO_SELLER]) /\\n                    _100_PCT_IN_BIPS\\n            );\\n        }\\n\\n        // Calculate seller's final share by substracting all the fees\\n        split[WHO_SELLER] = currentSplit[WHO_SELLER] - split[WHO_PROTOCOL] - split[WHO_MARKETPLACE] - calculatedArbitratorFee;\\n        split[WHO_BUYER] = currentSplit[WHO_BUYER];\\n        split[WHO_ARBITRATOR] = calculatedArbitratorFee;\\n\\n        return split;\\n    }\\n\\n    /// @inheritdoc IUnicrow\\n    function setClaimed(uint256 escrowId) external override onlyUnicrowClaim nonReentrant {\\n        escrows[escrowId].claimed = 1;\\n    }\\n}\\n\",\"keccak256\":\"0x7fe4360efcdcb2930d20039f042eaee6b6b980ffca41a8b1eec75b6cb02f1f92\",\"license\":\"MIT\"},\"contracts/UnicrowArbitrator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"./Unicrow.sol\\\";\\nimport \\\"./interfaces/IUnicrowArbitrator.sol\\\";\\nimport \\\"./interfaces/IUnicrowClaim.sol\\\";\\nimport \\\"./UnicrowTypes.sol\\\";\\n\\n/**\\n * @title Unicrow Arbitrator\\n * @notice Functionality for assigning an arbitrator to an escrow and for an arbitrator to decide a dispute\\n */\\ncontract UnicrowArbitrator is IUnicrowArbitrator, Context, ReentrancyGuard {\\n    using Address for address payable;\\n\\n    /// Reference to the main Unicrow contract\\n    Unicrow public immutable unicrow;\\n    \\n    /// Reference to the contract that manages claims from the escrows\\n    IUnicrowClaim public immutable unicrowClaim;\\n\\n    /// Stores information about arbitrators in relation to escrows\\n    mapping(uint256 => Arbitrator) public escrowArbitrator;\\n\\n    /**\\n     * @dev Emitted when an arbitrator has been proposed by one of the parties or\\n     * @dev if the other party sends a different proposal or also if the original party changes their proposal\\n     * @param escrowId Id of the escrow to which the proposer belongs\\n     * @param arbitrator Arbitrator's address\\n     * @param arbitratorFee Proposed fee in bips\\n     * @param proposer Address of the party that sent the proposal\\n    */\\n    event ArbitratorProposed(uint256 indexed escrowId, address arbitrator, uint16 arbitratorFee, address proposer);\\n\\n    /**\\n     * @dev Emitted when the arbitrator proposal was approved by the other party\\n     * @param escrowId Id of the escrow to which the proposer belongs\\n     * @param arbitrator Arbitrator's address\\n     * @param arbitratorFee Proposed fee in bips\\n    */\\n    event ArbitratorApproved(uint256 indexed escrowId, address arbitrator, uint256 arbitratorFee);\\n\\n    /**\\n     * @dev Emitted when the arbitrator has resolved a dispute\\n     * @param escrowId Id of the arbitrated escrow\\n     * @param escrow The escrow data, incl. the final split between buyer and seller as decided by the arbitrator\\n     * @param blockTime Timestamp of the block in which the transaction was minuted\\n     * @param amounts All amounts (i.e. incl. marketplace fee, arbitrator fee, and protocol fee) in the token\\n     */\\n    event Arbitrated(uint256 indexed escrowId, Escrow escrow, uint256 blockTime, uint256[5] amounts);\\n\\n    /**\\n     * The constructor provides immutable reference to the main escrow and claimMultiple contracts\\n     * @param unicrow_ Unicrow contract address\\n     * @param unicrowClaim_ UnicrowClaim contract address\\n     */\\n    constructor(\\n        address unicrow_,\\n        address unicrowClaim_\\n    ) {\\n        unicrow = Unicrow(payable(unicrow_));\\n        unicrowClaim = IUnicrowClaim(payable(unicrowClaim_));\\n    }\\n\\n    /**\\n     * @dev Checks if the provided address is either a buyer or a seller in the provided escrow\\n     * @param escrowId Id of the escrow to check\\n     * @param caller Address to check against\\n     */\\n    modifier onlyEscrowMember(uint256 escrowId, address caller) {\\n        require(_isEscrowMember(escrowId, caller), \\\"2-004\\\");\\n        _;\\n    }\\n\\n    /// @dev Checks if the caller is the Unicrow's main escrow contract\\n    modifier onlyUnicrow() {\\n        require(_msgSender() == address(unicrow));\\n        _;\\n    }\\n\\n    /// @inheritdoc IUnicrowArbitrator\\n    function setArbitrator(\\n        uint256 escrowId,\\n        address arbitrator,\\n        uint16 arbitratorFee\\n    ) external override onlyUnicrow {\\n        // Store arbitrator address and fee\\n        escrowArbitrator[escrowId].arbitrator = arbitrator;\\n        escrowArbitrator[escrowId].arbitratorFee = arbitratorFee;\\n\\n        // In this case, the arbitrator was set during the payment,\\n        // so it is considered to be based on the mutual consensus consensus\\n        escrowArbitrator[escrowId].buyerConsensus = true;\\n        escrowArbitrator[escrowId].sellerConsensus = true;\\n    }\\n\\n    /// @inheritdoc IUnicrowArbitrator\\n    function proposeArbitrator(\\n        uint256 escrowId,\\n        address arbitrator,\\n        uint16 arbitratorFee\\n    ) external override onlyEscrowMember(escrowId, _msgSender()) {\\n        Arbitrator storage arbitratorData = escrowArbitrator[escrowId];\\n        Escrow memory escrow = unicrow.getEscrow(escrowId);\\n\\n        // Arbitrator can't be address 0\\n        require(arbitrator != address(0), \\\"2-009\\\");\\n\\n        // Check if arbitrator is not the buyer or seller\\n        require(arbitrator != escrow.buyer && arbitrator != escrow.seller, \\\"2-010\\\");\\n\\n        // Check that arbitrator hasnt't been set already\\n        require(!arbitratorData.buyerConsensus || !arbitratorData.sellerConsensus,\\\"2-006\\\" );\\n\\n        // Make sure there's something left for the seller :-)\\n        require(escrow.marketplaceFee + escrow.split[WHO_PROTOCOL] + arbitratorFee < 10000, \\\"2-007\\\");\\n\\n        // Save the proposal parameters\\n        arbitratorData.arbitrator = arbitrator;\\n        arbitratorData.arbitratorFee = arbitratorFee;\\n\\n        // That the arbitrator is only proposed and not assigne is indicated by a lack of consensus\\n        if (_isEscrowBuyer(escrow, _msgSender())) {\\n            arbitratorData.buyerConsensus = true;\\n            arbitratorData.sellerConsensus = false;\\n        } else if (_isEscrowSeller(escrow, _msgSender())) {\\n            arbitratorData.sellerConsensus = true;\\n            arbitratorData.buyerConsensus = false;\\n        }\\n\\n        emit ArbitratorProposed(\\n            escrowId,\\n            arbitrator,\\n            arbitratorFee,\\n            _msgSender()\\n        );\\n    }\\n\\n    /// @inheritdoc IUnicrowArbitrator\\n    function approveArbitrator(uint256 escrowId, address validationAddress, uint16 validation)\\n        external\\n        override\\n        onlyEscrowMember(escrowId, _msgSender())\\n    {\\n        Arbitrator memory arbitratorData = getArbitratorData(escrowId);\\n        Escrow memory escrow = unicrow.getEscrow(escrowId);\\n\\n        // Check that the arbitrator has been proposed\\n        require(arbitratorData.arbitrator != address(0), \\\"2-008\\\");\\n\\n        // Compare the approval to the original proposal\\n        require(validationAddress == arbitratorData.arbitrator, \\\"2-008\\\");\\n        require(validation == arbitratorData.arbitratorFee, \\\"2-007\\\");\\n\\n        // Check that the buyer is approving seller's proposal (or vice versa) and if yes, confirm the consensus\\n        if (_isEscrowBuyer(escrow, _msgSender())) {\\n            require(\\n                arbitratorData.buyerConsensus == false,\\n                \\\"2-003\\\"\\n            );\\n            escrowArbitrator[escrowId].buyerConsensus = true;\\n        }\\n        if (_isEscrowSeller(escrow, _msgSender())) {\\n            require(\\n                arbitratorData.sellerConsensus == false,\\n                \\\"2-003\\\"\\n            );\\n            escrowArbitrator[escrowId].sellerConsensus = true;\\n        }\\n\\n        emit ArbitratorApproved(escrowId, arbitratorData.arbitrator, arbitratorData.arbitratorFee);\\n    }\\n\\n    /// @inheritdoc IUnicrowArbitrator\\n    function arbitrate(uint256 escrowId, uint16[2] calldata newSplit)\\n        external\\n        override\\n    {\\n        Arbitrator memory arbitratorData = getArbitratorData(escrowId);\\n        Escrow memory escrow = unicrow.getEscrow(escrowId);\\n\\n        // Check that this is this escrow's arbitrator calling\\n        require(_msgSender() == arbitratorData.arbitrator, \\\"2-005\\\");\\n        \\n        // Check that the arbitrator was set by mutual consensus\\n        require(\\n            arbitratorData.buyerConsensus && arbitratorData.sellerConsensus,\\n            \\\"2-001\\\"\\n        );\\n        \\n        // Ensure the splits equal 100%\\n        require(newSplit[WHO_BUYER] + newSplit[WHO_SELLER] == 10000, \\\"1-007\\\");\\n\\n        // Retain number of challenges in the final consensus record\\n        escrow.consensus[WHO_BUYER] = abs8(escrow.consensus[WHO_BUYER]) + 1;\\n        escrow.consensus[WHO_SELLER] = abs8(escrow.consensus[WHO_SELLER]);\\n\\n        // Update gross (pre-fees) splits as defined in the arbitration\\n        escrow.split[WHO_BUYER] = newSplit[WHO_BUYER];\\n        escrow.split[WHO_SELLER] = newSplit[WHO_SELLER];\\n\\n        // Execute settlement on the escrow\\n        unicrow.settle(\\n            escrowId,\\n            escrow.split,\\n            escrow.consensus\\n        );\\n\\n        // Set the payment as arbitrated\\n        escrowArbitrator[escrowId].arbitrated = true;\\n\\n        // Withdraw the amounts accordingly\\n        //   (this will take into account that arbitrator called this and will set arbitrator fee accordingly)\\n        uint256[5] memory amounts = unicrowClaim.claim(escrowId);\\n\\n        emit Arbitrated(escrowId, escrow, block.timestamp, amounts);\\n    }\\n\\n    /**\\n     * @dev Calculates final splits of all parties involved in the payment when the paymet is decided by an arbitrator.\\n     * @dev If seller's split is < 100% it will discount the marketplace and protocol fee, but (unlike when refunded by\\n     * @dev seller or settled mutually) will keep full Arbitrator fee and deduct it from both shares proportionally\\n     * @param currentSplit Current split in bips. See WHO_* contants for keys\\n     * @return Splits in bips using the same keys for the array\\n     */\\n    function arbitrationCalculation(\\n        uint16[5] calldata currentSplit\\n    ) public pure returns (uint16[5] memory) {\\n        uint16[5] memory split;\\n\\n        uint16 calculatedSellerArbitratorFee;\\n        uint16 calculatedBuyerArbitratorFee;\\n\\n        if(currentSplit[WHO_ARBITRATOR] > 0) {\\n            // Calculate buyer's portion of the arbitrator fee\\n            calculatedBuyerArbitratorFee = uint16(\\n                (uint256(currentSplit[WHO_ARBITRATOR])\\n                        * currentSplit[WHO_BUYER])\\n                        / _100_PCT_IN_BIPS\\n            );\\n            \\n             // Seller's portion of the arbitrator fee\\n            calculatedSellerArbitratorFee = uint16(\\n                (uint256(currentSplit[WHO_ARBITRATOR])\\n                    * currentSplit[WHO_SELLER])\\n                    / _100_PCT_IN_BIPS\\n            );\\n            \\n            // Store how much the arbitrator will get from each party\\n            split[WHO_ARBITRATOR] = calculatedBuyerArbitratorFee + calculatedSellerArbitratorFee;\\n        }\\n\\n        // Protocol fee\\n        if (currentSplit[WHO_PROTOCOL] > 0) {\\n            split[WHO_PROTOCOL] = uint16(\\n                (uint256(currentSplit[WHO_PROTOCOL])\\n                    * currentSplit[WHO_SELLER])\\n                    / _100_PCT_IN_BIPS\\n            );\\n        }\\n\\n        // Marketplace fee\\n        if (currentSplit[WHO_MARKETPLACE] > 0) {\\n            split[WHO_MARKETPLACE] = uint16(\\n                (uint256(currentSplit[WHO_MARKETPLACE])\\n                    * currentSplit[WHO_SELLER])\\n                    / _100_PCT_IN_BIPS\\n            );\\n        }\\n\\n        // Substract buyer's portion of the arbitartor fee from their share (if any)\\n        if(currentSplit[WHO_BUYER] > 0) {\\n            split[WHO_BUYER] = uint16(\\n                uint256(currentSplit[WHO_BUYER])\\n                        - calculatedBuyerArbitratorFee\\n                );\\n        }\\n\\n        // Marketplace, protocol, and seller's portion of the arbitartor fee are substracted from seller's share\\n        if(currentSplit[WHO_SELLER] > 0) {\\n            split[WHO_SELLER] = uint16(\\n                uint256(currentSplit[WHO_SELLER])\\n                    - split[WHO_PROTOCOL]\\n                    - split[WHO_MARKETPLACE]\\n                    - calculatedSellerArbitratorFee\\n                );\\n        }\\n\\n        return split;\\n    }\\n\\n    /// @inheritdoc IUnicrowArbitrator\\n    function getArbitratorData(uint256 escrowId)\\n        public\\n        override\\n        view\\n        returns (Arbitrator memory)\\n    {\\n        return escrowArbitrator[escrowId];\\n    }\\n\\n    /**\\n     * @dev Checks whether an address is a buyer in the provided escrow\\n     * @param escrowId Id of the escrow to check against\\n     * @param member_ the address to check\\n     */\\n    function _isEscrowMember(uint256 escrowId, address member_)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        Escrow memory escrow = unicrow.getEscrow(escrowId);\\n        return escrow.buyer == member_ || escrow.seller == member_;\\n    }\\n\\n    /**\\n     * @dev Checks whether an address is a buyer in the provided escrow\\n     * @param escrow Instance of escrow\\n     * @param _buyer the address to check\\n     */\\n    function _isEscrowBuyer(Escrow memory escrow, address _buyer)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return _buyer == escrow.buyer;\\n    }\\n\\n    /**\\n     * @dev Checks whether an address is a seller in the provided escrow\\n     * @param escrow Instance of escrow\\n     * @param _seller the address to check\\n     */\\n    function _isEscrowSeller(Escrow memory escrow, address _seller)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return _seller == escrow.seller;\\n    }\\n}\\n\",\"keccak256\":\"0xf89a9a3b721b8400928bd6b7d9f60b61d1933964947dd0b4c2dc3b6937bb6322\",\"license\":\"MIT\"},\"contracts/UnicrowClaim.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./interfaces/IUnicrowClaim.sol\\\";\\nimport \\\"./interfaces/IUnicrowStakingRewards.sol\\\";\\nimport \\\"./interfaces/IUnicrowClaimRewards.sol\\\";\\nimport \\\"./UnicrowArbitrator.sol\\\";\\nimport \\\"./Unicrow.sol\\\";\\nimport \\\"./UnicrowTypes.sol\\\";\\n\\n/**\\n * @title Contract for managing claims from Unicrow's escrow\\n */\\ncontract UnicrowClaim is IUnicrowClaim, Context, ReentrancyGuard {\\n    /// Reference to the main escrow contract (immutable)\\n    Unicrow public immutable unicrow;\\n\\n    /// Reference to the Arbitrator contract (immutable)\\n    UnicrowArbitrator public immutable unicrowArbitrator;\\n\\n    IUnicrowClaimRewards public crowRewards;\\n\\n    IUnicrowStakingRewards public stakingRewards;\\n\\n    /// Destination address of the protocol fee (governed)\\n    address public protocolFeeAddress;\\n    \\n    struct ClaimEvent {\\n        uint escrowId;\\n        uint[5] amount;\\n    }\\n\\n    /// Emitted when multiple escrows are claimed\\n    /// @param escrows data of all escrows that were claimed\\n    event Claim(ClaimEvent[] escrows);\\n\\n    /// Emitted when a single escrow payment is claimed\\n    /// @param escrow data of the claimed escrow\\n    event SingleClaim(ClaimEvent escrow);\\n\\n    /**\\n     * @param unicrow_ main escrow contract\\n     * @param unicrowArbitrator_ arbitration contract\\n     * @param protocolFeeAddress_ address to collect protocol fee\\n     */\\n    constructor(\\n        address unicrow_,\\n        address unicrowArbitrator_,\\n        address protocolFeeAddress_\\n    ) {\\n        unicrow = Unicrow(payable(unicrow_));\\n        unicrowArbitrator = UnicrowArbitrator(unicrowArbitrator_);\\n        protocolFeeAddress = protocolFeeAddress_;\\n    }\\n\\n    modifier onlyGovernance() {\\n        require(_msgSender() == unicrow.governanceAddress());\\n        _;\\n    }\\n\\n    /// @inheritdoc IUnicrowClaim\\n    function updateCrowRewards(address crowRewards_) external override onlyGovernance {\\n        crowRewards = IUnicrowClaimRewards(crowRewards_);\\n    }\\n\\n    /// @inheritdoc IUnicrowClaim\\n    function updateStakingRewards(address stakingRewards_) external override onlyGovernance {\\n        stakingRewards = IUnicrowStakingRewards(stakingRewards_);\\n    }\\n\\n    /// @inheritdoc IUnicrowClaim\\n    function updateProtocolFeeAddress(address protocolFeeAddress_) external override onlyGovernance {\\n        protocolFeeAddress = protocolFeeAddress_;\\n    }\\n\\n    /// @inheritdoc IUnicrowClaim\\n    function claimMultiple(uint[] calldata escrows) external override nonReentrant {\\n\\n        ClaimEvent[] memory events = new ClaimEvent[](escrows.length);\\n\\n        for (uint256 i = 0; i < escrows.length; ++i) {\\n            Escrow memory escrow = unicrow.getEscrow(escrows[i]);\\n\\n            Arbitrator memory arbitratorData = unicrowArbitrator\\n                .getArbitratorData(escrows[i]);\\n\\n            require(escrow.claimed == 0, \\\"0-005\\\");\\n\\n            require(\\n                (escrow.consensus[WHO_SELLER] >= 1 &&\\n                    escrow.consensus[WHO_BUYER] >= 1) ||\\n                    block.timestamp > escrow.challengePeriodEnd,\\n                \\\"0-006\\\"\\n            );\\n\\n            uint16[5] memory calculatedSplits = calculateSplits(\\n                arbitratorData,\\n                escrow\\n            );\\n\\n            uint256[5] memory payments = calculatePayments(\\n                escrow.amount,\\n                calculatedSplits\\n            );\\n\\n            address[5] memory addresses = [\\n                escrow.buyer,\\n                escrow.seller,\\n                escrow.marketplace,\\n                address(protocolFeeAddress),\\n                arbitratorData.arbitrator\\n            ];\\n\\n            claimPayments(escrows[i], payments, addresses, escrow.currency);\\n\\n            if(address(crowRewards) != address(0) && payments[WHO_PROTOCOL] > 0){\\n                crowRewards.distribute(escrow.currency, escrow.buyer, escrow.seller, payments[WHO_PROTOCOL]);\\n            }\\n\\n            if(address(stakingRewards) != address(0) && payments[WHO_PROTOCOL] > 0){\\n                stakingRewards.collectFee(escrow.currency, payments[WHO_PROTOCOL]);\\n            }\\n\\n            events[i] = ClaimEvent(escrows[i], payments);\\n        }\\n\\n        emit Claim(events);\\n    }\\n\\n    /// @inheritdoc IUnicrowClaim\\n    function claim(uint escrowId) external override nonReentrant returns(uint256[5] memory) {\\n        Escrow memory escrow = unicrow.getEscrow(escrowId);\\n\\n        Arbitrator memory arbitratorData = unicrowArbitrator\\n                .getArbitratorData(escrowId);\\n\\n        // Check that the payment hasn't been claimed yet\\n        require(escrow.claimed == 0, \\\"0-005\\\");\\n\\n        // Make sure both parties consented to releasing the payment from the escrow\\n        require(\\n            (escrow.consensus[WHO_SELLER] >= 1 &&\\n                escrow.consensus[WHO_BUYER] >= 1) ||\\n                block.timestamp > escrow.challengePeriodEnd,\\n            \\\"0-006\\\"\\n        );\\n\\n        // Calculate final splits (in bips) from gross splits\\n        uint16[5] memory calculatedSplits = calculateSplits(\\n            arbitratorData,\\n            escrow\\n        );\\n\\n        // Calculate amounts to be sent in the token\\n        uint256[5] memory payments = calculatePayments(\\n            escrow.amount,\\n            calculatedSplits\\n        );\\n\\n        // Prepare list of addresses for the withdrawals\\n        address[5] memory addresses = [\\n            escrow.buyer,\\n            escrow.seller,\\n            escrow.marketplace,\\n            address(protocolFeeAddress),\\n            arbitratorData.arbitrator\\n        ];\\n\\n        // Send the shares to the addresses\\n        claimPayments(escrowId, payments, addresses, escrow.currency);\\n\\n        if(address(crowRewards) != address(0) && payments[WHO_PROTOCOL] > 0){\\n            crowRewards.distribute(escrow.currency, escrow.buyer, escrow.seller, payments[WHO_PROTOCOL]);\\n        }\\n\\n        if(address(stakingRewards) != address(0) && payments[WHO_PROTOCOL] > 0){\\n            stakingRewards.collectFee(escrow.currency, payments[WHO_PROTOCOL]);\\n        }\\n\\n        // Emit the event incl. final amounts\\n        emit SingleClaim(ClaimEvent(escrowId, payments));\\n\\n        // Return the final amounts\\n        return [\\n            payments[WHO_BUYER],\\n            payments[WHO_SELLER],\\n            payments[WHO_MARKETPLACE],\\n            payments[WHO_PROTOCOL],\\n            payments[WHO_ARBITRATOR]\\n        ];\\n    }\\n\\n    /**\\n     * @dev Calculates how the balance in the escrow should be split between all the relevant parties\\n     * @param arbitrator Arbitrator information is not part of core escrow data, so data is provided separately here\\n     * @param escrow Escrow information\\n     */\\n    function calculateSplits(\\n        Arbitrator memory arbitrator,\\n        Escrow memory escrow\\n    ) internal view returns(uint16[5] memory) {\\n        uint16[5] memory split;\\n        \\n        // if the arbitrator was set, read their fee, otherwise set to 0\\n        bool arbitratorConsensus = arbitrator.buyerConsensus && arbitrator.sellerConsensus;\\n        uint16 arbitratorFee = arbitratorConsensus ? arbitrator.arbitratorFee : 0;\\n\\n        // The calculation will differ slightly based on whether the payment was decided by an arbitrator or not\\n        if(arbitrator.arbitrated) {\\n            split = unicrowArbitrator.arbitrationCalculation(\\n                [\\n                    escrow.split[WHO_BUYER],\\n                    escrow.split[WHO_SELLER],\\n                    escrow.split[WHO_MARKETPLACE],\\n                    escrow.split[WHO_PROTOCOL],\\n                    arbitratorFee\\n                ]\\n            );\\n        } else {\\n            split = unicrow.splitCalculation(\\n                [\\n                    escrow.split[WHO_BUYER],\\n                    escrow.split[WHO_SELLER],\\n                    escrow.split[WHO_MARKETPLACE],\\n                    escrow.split[WHO_PROTOCOL],\\n                    arbitratorFee\\n                ]\\n            );\\n        }\\n\\n        return split;\\n    }\\n\\n    /**\\n     * @dev Calculates actual amounts that should be sent to the parties\\n     * @param amount payment amount in escrow (in token)\\n     * @param split final splits\\n     */\\n    function calculatePayments(\\n        uint amount,\\n        uint16[5] memory split\\n    ) internal pure returns(uint256[5] memory) {\\n        uint256[5] memory payments;\\n\\n        // Multiply all the splits by the total amount\\n        payments[WHO_BUYER] = (uint256(split[WHO_BUYER]) * amount) / _100_PCT_IN_BIPS;\\n        payments[WHO_SELLER] = (uint256(split[WHO_SELLER]) * amount) / _100_PCT_IN_BIPS;\\n        payments[WHO_MARKETPLACE] = (uint256(split[WHO_MARKETPLACE]) * amount) / _100_PCT_IN_BIPS;\\n    \\n        // If the arbitrator decided the payment, they get their full fee\\n        // in such case, buyer's or seller split was reduced in the calling function)\\n        payments[WHO_ARBITRATOR] = (uint256(split[WHO_ARBITRATOR]) * amount) / _100_PCT_IN_BIPS;\\n\\n        // The rest of the amount goes to the protocol\\n        payments[WHO_PROTOCOL] = amount - payments[WHO_BUYER] - payments[WHO_SELLER] - payments[WHO_MARKETPLACE] - payments[WHO_ARBITRATOR];\\n\\n        return payments;\\n    }\\n\\n    /**\\n     * @dev Sends payments to the addresses of all the eligible parties\\n     * @param escrowId Id of the escrow\\n     * @param amounts amounts in token to claimMultiple\\n     * @param addresses destination addresses for each claimed share\\n     * @param currency address of the payment token\\n     */\\n    function claimPayments(\\n        uint escrowId,\\n        uint[5] memory amounts,\\n        address[5] memory addresses,\\n        address currency\\n    ) internal {\\n        unicrow.setClaimed(escrowId);\\n\\n        for (uint256 i = 0; i < 5; ++i) {\\n            if (amounts[i] > 0) {\\n                unicrow.sendEscrowShare(addresses[i], amounts[i], currency);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x325c85b9042c3483ab64a64ad16e18c3da9b67427696aeb42e86fb0e621c131d\",\"license\":\"MIT\"},\"contracts/UnicrowDispute.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"./interfaces/IUnicrowClaim.sol\\\";\\nimport \\\"./interfaces/IUnicrowDispute.sol\\\";\\nimport \\\"./interfaces/IUnicrowArbitrator.sol\\\";\\nimport \\\"./Unicrow.sol\\\";\\nimport \\\"./UnicrowTypes.sol\\\";\\n\\ncontract UnicrowDispute is IUnicrowDispute, Context, ReentrancyGuard {\\n    using Address for address payable;\\n\\n    /// Main Unicrow's escrow contract\\n    Unicrow public immutable unicrow;\\n\\n    /// Reference to the contract that manages claims from the escrow\\n    IUnicrowClaim public immutable unicrowClaim;\\n\\n    /// Reference to the Arbitration contract\\n    IUnicrowArbitrator public immutable unicrowArbitrator;\\n\\n    /// Stores information about which address sent the latest offer to settle a particular escrow identified by its ID\\n    mapping(uint256 => address) public latestSettlementOfferBy;\\n\\n    /// Stores information about the splits in the latest offer to settle an escrow identified by its ID\\n    mapping(uint256 => uint16[2]) public latestSettlementOffer;\\n\\n    /**\\n     * @dev Emitted when a challenge is sent for an escrow\\n     * @param escrowId ID of the challenged escrow\\n     * @param blockTime Timestamp when the challenge was minted\\n     * @param escrow information about the challenged escrow\\n    */\\n    event Challenge(uint256 indexed escrowId, uint256 blockTime, Escrow escrow);\\n\\n    /**\\n     * @dev Settlement offer (i.e. offer to split the escrow by defined shares) was sent by one of the parties\\n     * @param escrowId ID of the scrow for which a settlement was offered\\n     * @param blockTime Timestamp for when the offer was minted\\n     * @param latestSettlementOffer Splits [buyer's split, seller's split] as defined in the offer (in bips)\\n     * @param latestSettlementOfferBy address which sent the offer\\n     */\\n    event SettlementOffer(uint256 indexed escrowId, uint256 blockTime, uint16[2] latestSettlementOffer, address latestSettlementOfferBy);\\n\\n    /**\\n     * @dev Settlement offer was approved and the escrow was settled and claimed\\n     * @param escrowId ID of the escrow\\n     * @param escrow Details of the escrow\\n     * @param latestSettlementOffer Splits (in bips) in the settlement offer that was approved\\n     * @param blockTime Timestamp of when the settlement was minted\\n     * @param amounts amounts (in token) sent to addresses that were eligible to any shares and fees from the escrow\\n     */\\n    event ApproveOffer(uint256 indexed escrowId, Escrow escrow, uint16[2] latestSettlementOffer,uint256 blockTime, uint256[5] amounts);\\n\\n    /**\\n     * Constructor sets immutable references to the related Unicrow contracts\\n     */\\n    constructor(\\n        address unicrow_,\\n        address unicrowClaim_,\\n        address unicrowArbitrator_\\n    ) {\\n        unicrow = Unicrow(payable(unicrow_));\\n        unicrowClaim = IUnicrowClaim(payable(unicrowClaim_));\\n        unicrowArbitrator = IUnicrowArbitrator(unicrowArbitrator_);\\n    }\\n\\n    /// @inheritdoc IUnicrowDispute\\n    function challenge(uint256 escrowId) external override nonReentrant {\\n        address sender = _msgSender();\\n\\n        Escrow memory escrow = unicrow.getEscrow(escrowId);\\n\\n        // Only the escrow's seller and buyer can challenge\\n        require(sender == escrow.seller || sender == escrow.buyer, \\\"1-009\\\");\\n\\n        // The payment must be either in \\\"Paid\\\" or \\\"Challenged\\\" state\\n        require(\\n            escrow.consensus[WHO_SELLER] <= 0 ||\\n                escrow.consensus[WHO_BUYER] <= 0,\\n            \\\"1-005\\\"\\n        );\\n\\n        // Check that the challenge period is running\\n        require(block.timestamp <= escrow.challengePeriodEnd, \\\"1-016\\\");\\n        require(block.timestamp > escrow.challengePeriodStart, \\\"1-019\\\");\\n\\n        // Prevent reduntant challenge from seller's side\\n        require(\\n            sender != escrow.buyer ||\\n            escrow.consensus[WHO_BUYER] <= 0,\\n            \\\"1-014\\\"\\n        );\\n\\n        // Prevent reduntant challenge from buyer's side\\n        require(\\n            sender != escrow.seller ||\\n            escrow.consensus[WHO_SELLER] <= 0,\\n            \\\"1-015\\\"\\n        );\\n\\n        // Challenge does a few things:\\n        //   - sets split to 100/0% for the challenging party\\n        //   - sets the challenging party's consensus to positive and increases it by one\\n        //   - sets the challenged party consensus to negative\\n        // This way, if one of the parties has negative consensus, we know the payment is challenged\\n        //   and the absolute number keeps track of how many challenges have there been\\n        if (sender == escrow.buyer) {\\n            escrow.split[WHO_BUYER] = 10000;\\n            escrow.split[WHO_SELLER] = 0;\\n            escrow.consensus[WHO_BUYER] = abs8(escrow.consensus[WHO_BUYER]) + 1;\\n            escrow.consensus[WHO_SELLER] = -(abs8(escrow.consensus[WHO_SELLER]));\\n        } else if (sender == escrow.seller) {\\n            escrow.split[WHO_SELLER] = 10000;\\n            escrow.split[WHO_BUYER] = 0;\\n            escrow.consensus[WHO_BUYER] = -(abs8(escrow.consensus[WHO_BUYER]));\\n            escrow.consensus[WHO_SELLER] = abs8(escrow.consensus[WHO_SELLER]) + 1;\\n        }\\n\\n        // The new challenge period starts at the end of the current period\\n        //   and is extended by the time set in the original payment\\n        uint64 periodStart = escrow.challengePeriodEnd;\\n        uint64 periodEnd = escrow.challengePeriodEnd + escrow.challengeExtension;\\n\\n        // Execute the challenge in the main escrow contract\\n        unicrow.challenge(\\n            escrowId,\\n            escrow.split,\\n            escrow.consensus,\\n            periodStart,\\n            periodEnd\\n        );\\n\\n        // Update the challenge periods for the returned event\\n        escrow.challengePeriodStart = periodStart;\\n        escrow.challengePeriodEnd = periodEnd;\\n\\n        emit Challenge(escrowId, block.timestamp, escrow);\\n    }\\n\\n    /// @inheritdoc IUnicrowDispute\\n    function offerSettlement(uint256 escrowId, uint16[2] calldata newSplit)\\n        external\\n        override\\n        nonReentrant\\n    {\\n        address sender = _msgSender();\\n        Escrow memory escrow = unicrow.getEscrow(escrowId);\\n\\n        // Only buyer or seller can offer a settlement\\n        require(sender == escrow.buyer || sender == escrow.seller, \\\"1-009\\\");\\n\\n        // Check that the payment has not been released, refunded, or settled already\\n        require(\\n            escrow.consensus[WHO_SELLER] <= 0 ||\\n                escrow.consensus[WHO_BUYER] <= 0,\\n            \\\"1-005\\\"\\n        );\\n\\n        // Proposed splits should equal 100%\\n        require(newSplit[WHO_BUYER] + newSplit[WHO_SELLER] == 10000, \\\"1-007\\\");\\n\\n        // Record the latest offer details\\n        latestSettlementOfferBy[escrowId] = sender;\\n        latestSettlementOffer[escrowId] = newSplit;\\n\\n        emit SettlementOffer(escrowId, block.timestamp, newSplit, msg.sender);\\n    }\\n\\n    /// @inheritdoc IUnicrowDispute\\n    function approveSettlement(\\n        uint256 escrowId,\\n        uint16[2] calldata validation\\n    ) external override {\\n        address sender = _msgSender();\\n\\n        Escrow memory escrow = unicrow.getEscrow(escrowId);\\n\\n        address latestSettlementOfferByAddress = latestSettlementOfferBy[escrowId];\\n\\n        // Only buyer or seller can approve a settlement\\n        require(sender == escrow.buyer || sender == escrow.seller, \\\"1-009\\\");\\n\\n        // Check that there's a prior settlement offer\\n        require(latestSettlementOfferByAddress != address(0), \\\"1-017\\\");\\n\\n        // Only buyer can approve Seller's offer and vice versa\\n        require(sender != latestSettlementOfferByAddress, \\\"1-020\\\");\\n\\n        uint16[2] memory latestOffer = latestSettlementOffer[escrowId];\\n\\n        // Check that the splits sent for approval are the ones that were offered\\n        require(\\n            validation[WHO_BUYER] == latestOffer[WHO_BUYER] &&\\n            validation[WHO_SELLER] == latestOffer[WHO_SELLER],\\n            \\\"1-018\\\"\\n        );\\n\\n        uint16[4] memory split = escrow.split;\\n\\n        split[WHO_BUYER] = latestOffer[WHO_BUYER];\\n        split[WHO_SELLER] = latestOffer[WHO_SELLER];\\n\\n        // Update buyer and seller consensus to positive numbers\\n        escrow.consensus[WHO_BUYER] = abs8(escrow.consensus[WHO_BUYER]) + 1;\\n        escrow.consensus[WHO_SELLER] = abs8(escrow.consensus[WHO_SELLER]);\\n\\n        // Record the settlement in the main escrow contract\\n        unicrow.settle(\\n            escrowId,\\n            split,\\n            escrow.consensus\\n        );\\n\\n        // Sent shares to all the parties and read the final amounts\\n        uint256[5] memory amounts = unicrowClaim.claim(escrowId);\\n\\n        emit ApproveOffer(escrowId, escrow, latestOffer, block.timestamp, amounts);\\n    }\\n\\n    /**\\n     * Get details about the latest settlement offer\\n     * @param escrowId Id of the escrow to get settlement offer details for\\n     * @return Returns zero values in the returned object's fields if there's been no offer\\n     */\\n    function getSettlementDetails(uint256 escrowId) external view returns (Settlement memory) {\\n       Settlement memory settlement = Settlement(latestSettlementOfferBy[escrowId], latestSettlementOffer[escrowId]);\\n       return settlement;\\n    }\\n}\\n\",\"keccak256\":\"0x85d248b27f4825992cf866ad6538de3c01c7383caea566a97012bbd114694701\",\"license\":\"MIT\"},\"contracts/UnicrowTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nuint16 constant _100_PCT_IN_BIPS = 10000;\\n\\n// these constants are used as keys for consensus and split arrays\\nuint8 constant WHO_BUYER = 0;\\nuint8 constant WHO_SELLER = 1;\\nuint8 constant WHO_MARKETPLACE = 2;\\nuint8 constant WHO_PROTOCOL = 3;\\nuint8 constant WHO_ARBITRATOR = 4;\\n\\n/// @dev This is how information about each escrow is stored int he main contract, mapped to escrowId\\nstruct Escrow {\\n    /// @dev Who sent the payment\\n    address buyer;\\n\\n    /// @dev By how much will the challenge period get extended after a challenge (in seconds)\\n    uint64 challengeExtension;\\n\\n    /// @dev Whom is the payment for\\n    address seller;\\n\\n    /// @dev When does/has the current challenge period start(ed) (seconds in Unix epoch)\\n    uint64 challengePeriodStart;\\n\\n    /// @dev Address of a marketplace that has facilitated the trade (0x000...00 if none)\\n    address marketplace;\\n\\n    /// @dev Fee for the marketplace (can be 0 even if a marketplace was set but doesn't charge fee)\\n    uint256 marketplaceFee;\\n\\n    /// @dev When does the current challenge period end (seconds in Unix epoch)\\n    uint64 challengePeriodEnd;\\n\\n    /// @dev Token used in the payment (0x00..00 for ETH)\\n    address currency;\\n\\n    /// @dev True if the payment was already withdrawn from the escrow\\n    uint16 claimed;\\n\\n    /**\\n     * @dev Indicates status of the payment from buyer's and seller's side.\\n     * Negative value means that party was challenged.\\n     * Examples for various states:\\n     *  0, 1: Paid - If the payment is claimed after challenge period ends, consensus remains like this\\n     *  1, 1: Released by buyer\\n     *  1,-1: 1x Challenged by buyer - If the payment is claimed after CP ends, consensus remains like this\\n     * -1, 2: 1x Challenged by buyer and 1x by Seller\\n     *  2,-2: 2x Challenged by buyer, 1x by seller\\n     *  3, 2: Released, Refunded, or Settled. Deduct 1 from each consensus number to calculate number of challenges\\n     */\\n    int16[2] consensus;\\n\\n    /**\\n     * @dev Buyer's and Seller's share, and fees, in bips\\n     * Example of a new payment with 5% marketplace fee, 5% arbitrator fee: [0, 10000, 500, 500]\\n     * If the payment is refunded: [10000, 0, 0, 0]\\n     * If the payment is settled (e.g. 20% discount for the buyer): [8000, 2000, 500, 500]\\n     *\\n     * Note, that the sum of all splits can equal to more than 100% here.\\n     * The actual fees and shares are re-calculated when the payment is finally claimed\\n     */\\n    uint16[4] split;\\n\\n    /// @dev amount in the token\\n    uint256 amount;\\n}\\n\\n/// @dev Escrow parameters to be sent along with the deposit\\nstruct EscrowInput {\\n    /// @dev who should receive the payment\\n    address seller;\\n\\n    /// @dev address of a marketplace that has facilitated the payment\\n    address marketplace;\\n\\n    /// @dev Fee for the marketplace (can be 0 even if a marketplace was set but doesn't charge fee)\\n    uint16 marketplaceFee;\\n\\n    /// @dev Token used in the payment (0x00..00 for ETH)\\n    address currency;\\n\\n    /// @dev Initial challenge period (in seconds)\\n    uint32 challengePeriod;\\n\\n    /// @dev By how much will the challenge period get extended after a challenge (in seconds)\\n    uint32 challengeExtension;\\n\\n    /// @dev Amount in token\\n    uint256 amount;\\n}\\n\\n/// @dev Information about arbitrator proposed or assigned to an escrow.\\n/// @dev If both buyerConsensus and sellerConsensus are 1, the arbitrator is assigned, otherwise it's only been proposed by the party that has 1\\nstruct Arbitrator {\\n    /// @dev Address of the arbitrator. 0x00..00 for no arbitrator\\n    address arbitrator;\\n\\n    /// @dev Arbitrator's fee in bips. Can be 0\\n    uint16 arbitratorFee;\\n\\n    /// @dev Seller's agreement on the arbitrator\\n    bool sellerConsensus;\\n\\n    /// @dev Buyer's agreement on the arbitrator\\n    bool buyerConsensus;\\n\\n    /// @dev Has the escrow been decided by the arbitrator\\n    bool arbitrated;\\n}\\n\\n/// @dev Stores information about settlement, mapped to escrowId in UnicrowDispute contract\\nstruct Settlement {\\n    /// @dev address of who sent the latest settlement offer. Returns 0x00..00 if no offer has been made\\n    address latestSettlementOfferBy;\\n\\n    /// @dev how the payment was offered to be settled [buyer, seller] in bips\\n    uint16[2] latestSettlementOffer;\\n}\\n\\n/// @dev Information about the token used in the payment is returned in this structure\\nstruct Token {\\n    address address_;\\n    uint8 decimals;\\n    string symbol;\\n}\\n\\n/// @dev Superstructure that includes all the information relevant to an escrow\\nstruct Data {\\n    Escrow escrow;\\n    Arbitrator arbitrator;\\n    Settlement settlement;\\n    Token token;\\n}\\n\\nfunction abs8(int16 x) pure returns (int16) {\\n    return x >= 0 ? x : -x;\\n}\",\"keccak256\":\"0xa170d9db7e9d975040c77d136e07b6267dca24dea097b8c5fbdb98c4291031c1\",\"license\":\"MIT\"},\"contracts/interfaces/IUnicrow.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.7;\\n\\nimport \\\"../UnicrowTypes.sol\\\";\\n\\ninterface IUnicrow {\\n  /**\\n   * @notice Deposit ETH or SafeERC20 to open a new escrow payment.\\n   * @notice We don't white- or black-list, but we strongly discourage users from using ERC777 tokens\\n   * @notice   and any ERC20 tokens which perform extra logic in their transfer functions. \\n   * @notice If the balance claiming transaction fails due to the token's contract error or malicious behavior, \\n   * @notice   it is not possible to try to claim the balance again.\\n   * @dev Escrow ID is generated automatically by the contract\\n   * @param input Escrow input (seller, marketplace, currency, and challenge period information)\\n   * @param arbitrator Arbitrator address (submit zero address to not set an arbitrator)\\n   * @param arbitratorFee Arbitrator Fee\\n   */\\n  function pay(\\n    EscrowInput memory input,\\n    address arbitrator,\\n    uint16 arbitratorFee\\n  ) external payable;\\n\\n  /**\\n   * @notice Function called by UnicrowDispute to execute a challenge\\n   * @dev can be called by UnicrowDispute only\\n   * @param escrowId ID of the challenged escrow payment\\n   * @param split New split (bips)\\n   * @param consensus New consensus\\n   * @param challengeStart When the new challenge period starts\\n   * @param challengeEnd When the new challenge period ends\\n   */\\n  function challenge(\\n    uint256 escrowId,\\n    uint16[4] memory split,\\n    int16[2] memory consensus,\\n    uint64 challengeStart,\\n    uint64 challengeEnd\\n  ) external;\\n\\n  /**\\n   * @notice Refund 100% of the buyer payment (all fees are waived).\\n   * @dev Can be called only by the Seller\\n   * @param escrowId ID of the escrow to be refunded\\n   */\\n  function refund(uint escrowId) external;\\n\\n  /**\\n   * @notice Release the payment to the seller and to all other parties that charge a fee from it.\\n   * @dev Can be called by the Buyer only\\n   * @param escrowId ID of the escrow to be released\\n   */\\n  function release(uint escrowId) external;\\n\\n  /**\\n   * @notice Settle a payment (i.e. split it with arbitrary shares between the buyer and the seller). Fees are reduced proportionally to the seller's share.\\n   * @dev Can be called only by UnicrowDispute\\n   * @param escrowId ID of the escrow to be settled\\n   * @param split New split in bips (total must equal 10000)\\n   * @param consensus New consensus\\n   */\\n  function settle(\\n    uint256 escrowId,\\n    uint16[4] memory split,\\n    int16[2] memory consensus\\n    ) external;\\n\\n  /**\\n   * @notice Calculating the final splits (incl. fees) based on how the payment is concluded.\\n   * @dev The currentSplit is not expected to equal 100% in total. Buyer and seller splits should equal 100 based\\n   * on how the payment is settled, other splits represent fees which will get reduced and deducted accordingly\\n   * @param currentSplit Current splits in bips\\n   */\\n  function splitCalculation(\\n    uint16[5] calldata currentSplit\\n  ) external returns(uint16[5] memory);\\n\\n  /**\\n   * @dev Get the escrow data (without arbitrator or settlement information)\\n   * @param escrowId ID of the escrow to retrieve information of\\n   */\\n  function getEscrow(\\n    uint256 escrowId\\n  ) external returns(Escrow memory);\\n\\n  /**\\n   * @notice Set the escrow as claimed (i.e. that its balance has been sent to all the parties involved).\\n   * @dev Callable only by other Unicrow contracts\\n   * @param escrowId ID of the escrow to set as claimed\\n   */\\n  function setClaimed(uint escrowId) external;\\n\\n  /**\\n   * @notice Update protocol fee (governance only, cannot be more than 1%)\\n   * @param fee New protocol fee (bips)\\n   */\\n  function updateEscrowFee(uint16 fee) external;\\n\\n  /**\\n   * @notice Update governance contract address (governable)\\n   * @param governance New governance address\\n   */\\n  function updateGovernance(address governance) external;\\n}\\n\",\"keccak256\":\"0xea7694ef3e4affe0cbf2dfb619ce94312548558b2609bd978a8a2e3023206070\",\"license\":\"GPL-2.0-or-later\"},\"contracts/interfaces/IUnicrowArbitrator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"../UnicrowTypes.sol\\\";\\n\\ninterface IUnicrowArbitrator {\\n    /**\\n     * Assigns an arbitrator to an escrow.\\n     * @dev Called by Unicrow.pay()\\n     * @param escrowId Id of the escrow\\n     * @param arbitrator Arbitrator's address\\n     * @param arbitratorFee Arbitrator fee in bips (can be 0)\\n      */\\n    function setArbitrator(uint256 escrowId, address arbitrator, uint16 arbitratorFee) external;\\n\\n    /**\\n     * One of the parties (buyer or seller) can call this to propose an arbitrator\\n     * for an escrow that has no arbitrator defined\\n     * @param escrowId Id of the escrow\\n     * @param arbitrator Arbitrator's address\\n     * @param arbitratorFee Arbitrator fee in bips (can be 0)\\n      */\\n    function proposeArbitrator(uint256 escrowId, address arbitrator, uint16 arbitratorFee) external;\\n\\n    /**\\n     * Approve an arbitrator proposed by another party (i.e. by seller if buyer proposed, by buyer if seller proposed).\\n     * @dev To ensure the user approves an arbitrator they wanted, it requires the same parameters as proposal\\n     * @param escrowId Id of an escrow\\n     * @param validationAddress Arbitrator's address - will be compared with the existing proposal\\n     * @param validation Arbitrator's Fee - will be compared with the existing proposal\\n    */\\n    function approveArbitrator(uint256 escrowId, address validationAddress, uint16 validation) external;\\n\\n    /**\\n     * Arbitrate an payment - to be called only by an escrow's arbitrator\\n     * @param escrowId Id of an escrow\\n     * @param newSplit How the payment should be split between buyer [0] and seller [1]. [100, 0] will refund the payment to the buyer, [0, 100] will release it to the seller, anything in between will\\n     */\\n    function arbitrate(uint256 escrowId, uint16[2] memory newSplit) external;\\n\\n    /**\\n     * Get information about proposed or assigned arbitrator.\\n     * @dev buyerConsensus and sellerConsensus indicate if the arbitrator was only proposed by one of the parties or\\n     * @dev has been assigned by the mutual consensus\\n     * @return Arbitrator information.\\n     * @param escrowId ID of the escrow\\n     */\\n    function getArbitratorData(uint256 escrowId) external view returns(Arbitrator memory);\\n}\\n\",\"keccak256\":\"0xf8f2df97eca4816ce542763bd459eff9c649ba85c70eb573a9451644dbea6357\",\"license\":\"MIT\"},\"contracts/interfaces/IUnicrowClaim.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface IUnicrowClaim {\\n    /// @notice Claim multiple escrows.\\n    /// @dev To save everyone's gas costs, it claims balances and fees of all parties that are eligible for a share from the escrow\\n    /// @param escrows List of escrows to be claimed.\\n    function claimMultiple(uint[] memory escrows) external;\\n\\n    /// @notice Claim a single escrow\\n    /// @dev To save everyone's gas costs, it claims balances and fees of all parties that are eligible for a share from the escrow\\n    /// @param escrowId escrow to be claimed\\n    function claim(uint escrowId) external returns(uint256[5] memory);\\n\\n    // @notice Update rewards contract pointer (governable)\\n    // @param crowRewards_ New rewards address\\n    function updateCrowRewards(address crowRewards_) external;\\n\\n    // @notice Update staking rewards contract pointer (governable)\\n    // @param stakingRewards_ New staking rewards address\\n    function updateStakingRewards(address crowRewards_) external;\\n\\n    // @notice Update protocol fee collection address (governable)\\n    // @param protocolFeeAddress_ New protocol fee collection address\\n    function updateProtocolFeeAddress(address protocolFeeAddress_) external;\\n}\\n\",\"keccak256\":\"0x143bfdf568bf9897babb4644ac5faa4ba866635b4b176b9c2bce6f25bf458d95\",\"license\":\"MIT\"},\"contracts/interfaces/IUnicrowClaimRewards.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IUnicrowClaimRewards {\\n    function distribute(address token, address buyer, address seller, uint256 fee) external;\\n}\\n\",\"keccak256\":\"0x5ca6ef474f894df689a1059ee1ffe7f5c4a5e786e3cd0f7b4adfdc1396b81cfb\",\"license\":\"MIT\"},\"contracts/interfaces/IUnicrowDispute.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\nimport \\\"../UnicrowTypes.sol\\\";\\n\\ninterface IUnicrowDispute {\\n  /**\\n   * Challenge a payment. If the challenge is successful (the criteria are met),\\n   * it sets whoever sent the challenge as a payee and sets a new challenge period\\n   * @param escrowId Id of the escrow that's being challenged\\n   */\\n  function challenge(uint256 escrowId) external;\\n\\n  /**\\n   * Send an offer to settle the payment between the buyer and the seller\\n   * @param escrowId ID of the escrow for which the offer is sent\\n   * @param newSplit the new settlement proposal ([buyerSplit, sellerSplit] in bips, sum must equal 10000)\\n   */\\n  function offerSettlement(uint256 escrowId, uint16[2] memory newSplit) external;\\n\\n  /**\\n   * Approve an offer to settle the payment between the buyer and the seller\\n   * @param escrowId ID of the escrow for which the offer is sent\\n   * @param validation the settlement proposal that must be equal to an offer sent by the other party\\n   */\\n  function approveSettlement(uint256 escrowId,uint16[2] memory validation) external;\\n}\\n\",\"keccak256\":\"0x8d3220d0acac753e2fd1b0d8d7b2ea05e27805358794a8ee278e41c943381fc7\",\"license\":\"MIT\"},\"contracts/interfaces/IUnicrowStakingRewards.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IUnicrowStakingRewards {\\n    /// @notice Collect payments fee to staking rewards\\n    /// @param token Token address\\n    /// @param amount Paid fee\\n    function collectFee(address token, uint256 amount) external;\\n}\\n\",\"keccak256\":\"0xc4155b9f8a0579c5a532814e4ac6527c68891286f617b12f225e801dd5e3daf8\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c06040523480156200001157600080fd5b5060405162001b9638038062001b96833981016040819052620000349162000097565b6001600055606092831b6001600160601b03199081166080529190921b1660a052600380546001600160a01b0319166001600160a01b03909216919091179055620000e1565b80516001600160a01b03811681146200009257600080fd5b919050565b600080600060608486031215620000ad57600080fd5b620000b8846200007a565b9250620000c8602085016200007a565b9150620000d8604085016200007a565b90509250925092565b60805160601c60a05160601c611a3d620001596000396000818160f10152818161032f015281816109000152610ed80152600081816101580152818161026f015281816106ac0152818161084501528181610cd801528181610db5015281816110070152818161125301526112e40152611a3d6000f3fe608060405234801561001057600080fd5b50600436106100be5760003560e01c80639051cce911610076578063a76b8fb71161005b578063a76b8fb7146101a0578063cce516b7146101b3578063eeca9a31146101c657600080fd5b80639051cce91461017a57806394417bce1461018d57600080fd5b80634cb6995a116100a75780634cb6995a1461012b57806364b87a70146101405780636e4e29341461015357600080fd5b8063379607f5146100c357806349c4920f146100ec575b600080fd5b6100d66100d1366004611814565b6101d9565b6040516100e391906118f4565b60405180910390f35b6101137f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100e3565b61013e610139366004611566565b6106aa565b005b600254610113906001600160a01b031681565b6101137f000000000000000000000000000000000000000000000000000000000000000081565b61013e61018836600461162a565b610787565b600154610113906001600160a01b031681565b61013e6101ae366004611566565b610cd6565b600354610113906001600160a01b031681565b61013e6101d4366004611566565b610db3565b6101e16113d8565b600260005414156102395760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064015b60405180910390fd5b600260009081556040517f7d19e596000000000000000000000000000000000000000000000000000000008152600481018490527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690637d19e596906024016102006040518083038186803b1580156102ba57600080fd5b505afa1580156102ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f2919061172f565b6040517f16e0551b000000000000000000000000000000000000000000000000000000008152600481018590529091506000906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906316e0551b9060240160a06040518083038186803b15801561037157600080fd5b505afa158015610385573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103a9919061169f565b905081610100015161ffff166000146103ec5760405162461bcd60e51b8152602060048201526005602482015264302d30303560d81b6044820152606401610230565b61012082015160200151600190810b12801590610413575061012082015151600190810b12155b8061042b57508160c0015167ffffffffffffffff1642115b61045f5760405162461bcd60e51b8152602060048201526005602482015264181698181b60d91b6044820152606401610230565b600061046b8284610e90565b9050600061047e8461016001518361113c565b6040805160a08101825286516001600160a01b0390811682528783015181166020830152608080890151821693830193909352600354811660608301528651169181019190915260e0860151919250906104dd90889084908490611224565b6001546001600160a01b0316158015906104fa5750606082015115155b156105835760015460e0860151865160408089015160608701519151631d9dc2a760e21b81526001600160a01b03948516600482015292841660248401528316604483015260648201529116906376770a9c90608401600060405180830381600087803b15801561056a57600080fd5b505af115801561057e573d6000803e3d6000fd5b505050505b6002546001600160a01b0316158015906105a05750606082015115155b156106165760025460e08601516060840151604051630bb03fdb60e21b81526001600160a01b0392831660048201526024810191909152911690632ec0ff6c90604401600060405180830381600087803b1580156105fd57600080fd5b505af1158015610611573d6000803e3d6000fd5b505050505b7f4dcc1cbd3586ce0ab63396e3e3601351a6fd799aec0cd7bd65761110335335606040518060400160405280898152602001848152506040516106599190611902565b60405180910390a1506040805160a081018252825181526020808401519082015282820151918101919091526060808301519082015260809182015191810191909152600160005595945050505050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663795053d36040518163ffffffff1660e01b815260040160206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b919061158a565b6001600160a01b0316336001600160a01b03161461075857600080fd5b6003805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b600260005414156107da5760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610230565b600260009081558167ffffffffffffffff8111156107fa576107fa6119d9565b60405190808252806020026020018201604052801561083357816020015b6108206113f6565b8152602001906001900390816108185790505b50905060005b82811015610c945760007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316637d19e596868685818110610884576108846119c3565b905060200201356040518263ffffffff1660e01b81526004016108a991815260200190565b6102006040518083038186803b1580156108c257600080fd5b505afa1580156108d6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108fa919061172f565b905060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166316e0551b87878681811061093f5761093f6119c3565b905060200201356040518263ffffffff1660e01b815260040161096491815260200190565b60a06040518083038186803b15801561097c57600080fd5b505afa158015610990573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b4919061169f565b905081610100015161ffff166000146109f75760405162461bcd60e51b8152602060048201526005602482015264302d30303560d81b6044820152606401610230565b61012082015160200151600190810b12801590610a1e575061012082015151600190810b12155b80610a3657508160c0015167ffffffffffffffff1642115b610a6a5760405162461bcd60e51b8152602060048201526005602482015264181698181b60d91b6044820152606401610230565b6000610a768284610e90565b90506000610a898461016001518361113c565b6040805160a08101825286516001600160a01b03908116825287830151811660208301526080808901518216938301939093526003548116606083015286511691810191909152909150610afb898988818110610ae857610ae86119c3565b9050602002013583838860e00151611224565b6001546001600160a01b031615801590610b185750606082015115155b15610ba15760015460e0860151865160408089015160608701519151631d9dc2a760e21b81526001600160a01b03948516600482015292841660248401528316604483015260648201529116906376770a9c90608401600060405180830381600087803b158015610b8857600080fd5b505af1158015610b9c573d6000803e3d6000fd5b505050505b6002546001600160a01b031615801590610bbe5750606082015115155b15610c345760025460e08601516060840151604051630bb03fdb60e21b81526001600160a01b0392831660048201526024810191909152911690632ec0ff6c90604401600060405180830381600087803b158015610c1b57600080fd5b505af1158015610c2f573d6000803e3d6000fd5b505050505b60405180604001604052808a8a89818110610c5157610c516119c3565b90506020020135815260200183815250878781518110610c7357610c736119c3565b6020026020010181905250505050505080610c8d90611992565b9050610839565b507f05270dc3f040b6099aa59b4dc25043ad9d14706a809c4dd4ad6356935332b85181604051610cc49190611871565b60405180910390a15050600160005550565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663795053d36040518163ffffffff1660e01b815260040160206040518083038186803b158015610d2f57600080fd5b505afa158015610d43573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d67919061158a565b6001600160a01b0316336001600160a01b031614610d8457600080fd5b6001805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663795053d36040518163ffffffff1660e01b815260040160206040518083038186803b158015610e0c57600080fd5b505afa158015610e20573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e44919061158a565b6001600160a01b0316336001600160a01b031614610e6157600080fd5b6002805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b610e986113d8565b610ea06113d8565b600084606001518015610eb4575084604001515b9050600081610ec4576000610eca565b85602001515b9050856080015115611005577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316634c403c536040518060a00160405280886101400151600060ff1660048110610f2b57610f2b6119c3565b6020908102919091015161ffff90811683526101408b018051830151821692840192909252815160409081015182168185015291516060908101518216908401528616608090920191909152517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b168152610fae91906004016118bf565b60a06040518083038186803b158015610fc657600080fd5b505afa158015610fda573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ffe91906115a7565b9250611130565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663d02f411e6040518060a00160405280886101400151600060ff166004811061105a5761105a6119c3565b6020908102919091015161ffff90811683526101408b018051830151821692840192909252815160409081015182168185015291516060908101518216908401528616608090920191909152517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b1681526110dd91906004016118bf565b60a06040518083038186803b1580156110f557600080fd5b505afa158015611109573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061112d91906115a7565b92505b50909150505b92915050565b6111446113d8565b61114c6113d8565b82516127109061116190869061ffff1661195c565b61116b919061193a565b815260208301516127109061118590869061ffff1661195c565b61118f919061193a565b60208201526040830151612710906111ac90869061ffff1661195c565b6111b6919061193a565b60408201526080830151612710906111d390869061ffff1661195c565b6111dd919061193a565b608082018190526040820151602083015183516111fa908861197b565b611204919061197b565b61120e919061197b565b611218919061197b565b60608201529392505050565b6040517fe7aa0bd7000000000000000000000000000000000000000000000000000000008152600481018590527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063e7aa0bd790602401600060405180830381600087803b15801561129f57600080fd5b505af11580156112b3573d6000803e3d6000fd5b5050505060005b60058110156113d15760008482600581106112d7576112d76119c3565b602002015111156113c1577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638ede1f05848360058110611323576113236119c3565b602002015186846005811061133a5761133a6119c3565b60200201516040517fffffffff0000000000000000000000000000000000000000000000000000000060e085901b1681526001600160a01b03928316600482015260248101919091529085166044820152606401600060405180830381600087803b1580156113a857600080fd5b505af11580156113bc573d6000803e3d6000fd5b505050505b6113ca81611992565b90506112ba565b5050505050565b6040518060a001604052806005906020820280368337509192915050565b6040518060400160405280600081526020016114106113d8565b905290565b8051611420816119ef565b919050565b600082601f83011261143657600080fd5b6040516040810181811067ffffffffffffffff82111715611459576114596119d9565b806040525080838560408601111561147057600080fd5b6000805b60028110156114a25782518060010b811461148d578283fd5b84526020938401939290920191600101611474565b50929695505050505050565b600082601f8301126114bf57600080fd5b6040516080810181811067ffffffffffffffff821117156114e2576114e26119d9565b6040528083608081018610156114f757600080fd5b60005b60048110156115215761150c8261153c565b835260209283019291909101906001016114fa565b509195945050505050565b8051801515811461142057600080fd5b805161ffff8116811461142057600080fd5b805167ffffffffffffffff8116811461142057600080fd5b60006020828403121561157857600080fd5b8135611583816119ef565b9392505050565b60006020828403121561159c57600080fd5b8151611583816119ef565b600060a082840312156115b957600080fd5b82601f8301126115c857600080fd5b60405160a0810181811067ffffffffffffffff821117156115eb576115eb6119d9565b604052808360a0810186101561160057600080fd5b60005b6005811015611521576116158261153c565b83526020928301929190910190600101611603565b6000806020838503121561163d57600080fd5b823567ffffffffffffffff8082111561165557600080fd5b818501915085601f83011261166957600080fd5b81358181111561167857600080fd5b8660208260051b850101111561168d57600080fd5b60209290920196919550909350505050565b600060a082840312156116b157600080fd5b60405160a0810181811067ffffffffffffffff821117156116d4576116d46119d9565b60405282516116e2816119ef565b81526116f06020840161153c565b60208201526117016040840161152c565b60408201526117126060840161152c565b60608201526117236080840161152c565b60808201529392505050565b6000610200828403121561174257600080fd5b61174a611910565b61175383611415565b81526117616020840161154e565b602082015261177260408401611415565b60408201526117836060840161154e565b606082015261179460808401611415565b608082015260a083015160a08201526117af60c0840161154e565b60c08201526117c060e08401611415565b60e08201526101006117d381850161153c565b908201526101206117e685858301611425565b908201526101606117f9858583016114ae565b6101408301526101e084015181830152508091505092915050565b60006020828403121561182657600080fd5b5035919050565b8060005b6005811015611850578151845260209384019390910190600101611831565b50505050565b80518252602081015161186c602084018261182d565b505050565b6020808252825182820181905260009190848201906040850190845b818110156118b3576118a0838551611856565b9284019260c0929092019160010161188d565b50909695505050505050565b60a08101818360005b60058110156118eb57815161ffff168352602092830192909101906001016118c8565b50505092915050565b60a08101611136828461182d565b60c081016111368284611856565b604051610180810167ffffffffffffffff81118282101715611934576119346119d9565b60405290565b60008261195757634e487b7160e01b600052601260045260246000fd5b500490565b6000816000190483118215151615611976576119766119ad565b500290565b60008282101561198d5761198d6119ad565b500390565b60006000198214156119a6576119a66119ad565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b0381168114611a0457600080fd5b5056fea264697066735822122085515bdc3a8067067f4efc1330f48367e652e40831b9ee7f0e3881433c6080b264736f6c63430008070033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100be5760003560e01c80639051cce911610076578063a76b8fb71161005b578063a76b8fb7146101a0578063cce516b7146101b3578063eeca9a31146101c657600080fd5b80639051cce91461017a57806394417bce1461018d57600080fd5b80634cb6995a116100a75780634cb6995a1461012b57806364b87a70146101405780636e4e29341461015357600080fd5b8063379607f5146100c357806349c4920f146100ec575b600080fd5b6100d66100d1366004611814565b6101d9565b6040516100e391906118f4565b60405180910390f35b6101137f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100e3565b61013e610139366004611566565b6106aa565b005b600254610113906001600160a01b031681565b6101137f000000000000000000000000000000000000000000000000000000000000000081565b61013e61018836600461162a565b610787565b600154610113906001600160a01b031681565b61013e6101ae366004611566565b610cd6565b600354610113906001600160a01b031681565b61013e6101d4366004611566565b610db3565b6101e16113d8565b600260005414156102395760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064015b60405180910390fd5b600260009081556040517f7d19e596000000000000000000000000000000000000000000000000000000008152600481018490527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690637d19e596906024016102006040518083038186803b1580156102ba57600080fd5b505afa1580156102ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f2919061172f565b6040517f16e0551b000000000000000000000000000000000000000000000000000000008152600481018590529091506000906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906316e0551b9060240160a06040518083038186803b15801561037157600080fd5b505afa158015610385573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103a9919061169f565b905081610100015161ffff166000146103ec5760405162461bcd60e51b8152602060048201526005602482015264302d30303560d81b6044820152606401610230565b61012082015160200151600190810b12801590610413575061012082015151600190810b12155b8061042b57508160c0015167ffffffffffffffff1642115b61045f5760405162461bcd60e51b8152602060048201526005602482015264181698181b60d91b6044820152606401610230565b600061046b8284610e90565b9050600061047e8461016001518361113c565b6040805160a08101825286516001600160a01b0390811682528783015181166020830152608080890151821693830193909352600354811660608301528651169181019190915260e0860151919250906104dd90889084908490611224565b6001546001600160a01b0316158015906104fa5750606082015115155b156105835760015460e0860151865160408089015160608701519151631d9dc2a760e21b81526001600160a01b03948516600482015292841660248401528316604483015260648201529116906376770a9c90608401600060405180830381600087803b15801561056a57600080fd5b505af115801561057e573d6000803e3d6000fd5b505050505b6002546001600160a01b0316158015906105a05750606082015115155b156106165760025460e08601516060840151604051630bb03fdb60e21b81526001600160a01b0392831660048201526024810191909152911690632ec0ff6c90604401600060405180830381600087803b1580156105fd57600080fd5b505af1158015610611573d6000803e3d6000fd5b505050505b7f4dcc1cbd3586ce0ab63396e3e3601351a6fd799aec0cd7bd65761110335335606040518060400160405280898152602001848152506040516106599190611902565b60405180910390a1506040805160a081018252825181526020808401519082015282820151918101919091526060808301519082015260809182015191810191909152600160005595945050505050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663795053d36040518163ffffffff1660e01b815260040160206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b919061158a565b6001600160a01b0316336001600160a01b03161461075857600080fd5b6003805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b600260005414156107da5760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610230565b600260009081558167ffffffffffffffff8111156107fa576107fa6119d9565b60405190808252806020026020018201604052801561083357816020015b6108206113f6565b8152602001906001900390816108185790505b50905060005b82811015610c945760007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316637d19e596868685818110610884576108846119c3565b905060200201356040518263ffffffff1660e01b81526004016108a991815260200190565b6102006040518083038186803b1580156108c257600080fd5b505afa1580156108d6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108fa919061172f565b905060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166316e0551b87878681811061093f5761093f6119c3565b905060200201356040518263ffffffff1660e01b815260040161096491815260200190565b60a06040518083038186803b15801561097c57600080fd5b505afa158015610990573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b4919061169f565b905081610100015161ffff166000146109f75760405162461bcd60e51b8152602060048201526005602482015264302d30303560d81b6044820152606401610230565b61012082015160200151600190810b12801590610a1e575061012082015151600190810b12155b80610a3657508160c0015167ffffffffffffffff1642115b610a6a5760405162461bcd60e51b8152602060048201526005602482015264181698181b60d91b6044820152606401610230565b6000610a768284610e90565b90506000610a898461016001518361113c565b6040805160a08101825286516001600160a01b03908116825287830151811660208301526080808901518216938301939093526003548116606083015286511691810191909152909150610afb898988818110610ae857610ae86119c3565b9050602002013583838860e00151611224565b6001546001600160a01b031615801590610b185750606082015115155b15610ba15760015460e0860151865160408089015160608701519151631d9dc2a760e21b81526001600160a01b03948516600482015292841660248401528316604483015260648201529116906376770a9c90608401600060405180830381600087803b158015610b8857600080fd5b505af1158015610b9c573d6000803e3d6000fd5b505050505b6002546001600160a01b031615801590610bbe5750606082015115155b15610c345760025460e08601516060840151604051630bb03fdb60e21b81526001600160a01b0392831660048201526024810191909152911690632ec0ff6c90604401600060405180830381600087803b158015610c1b57600080fd5b505af1158015610c2f573d6000803e3d6000fd5b505050505b60405180604001604052808a8a89818110610c5157610c516119c3565b90506020020135815260200183815250878781518110610c7357610c736119c3565b6020026020010181905250505050505080610c8d90611992565b9050610839565b507f05270dc3f040b6099aa59b4dc25043ad9d14706a809c4dd4ad6356935332b85181604051610cc49190611871565b60405180910390a15050600160005550565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663795053d36040518163ffffffff1660e01b815260040160206040518083038186803b158015610d2f57600080fd5b505afa158015610d43573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d67919061158a565b6001600160a01b0316336001600160a01b031614610d8457600080fd5b6001805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663795053d36040518163ffffffff1660e01b815260040160206040518083038186803b158015610e0c57600080fd5b505afa158015610e20573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e44919061158a565b6001600160a01b0316336001600160a01b031614610e6157600080fd5b6002805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b610e986113d8565b610ea06113d8565b600084606001518015610eb4575084604001515b9050600081610ec4576000610eca565b85602001515b9050856080015115611005577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316634c403c536040518060a00160405280886101400151600060ff1660048110610f2b57610f2b6119c3565b6020908102919091015161ffff90811683526101408b018051830151821692840192909252815160409081015182168185015291516060908101518216908401528616608090920191909152517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b168152610fae91906004016118bf565b60a06040518083038186803b158015610fc657600080fd5b505afa158015610fda573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ffe91906115a7565b9250611130565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663d02f411e6040518060a00160405280886101400151600060ff166004811061105a5761105a6119c3565b6020908102919091015161ffff90811683526101408b018051830151821692840192909252815160409081015182168185015291516060908101518216908401528616608090920191909152517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b1681526110dd91906004016118bf565b60a06040518083038186803b1580156110f557600080fd5b505afa158015611109573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061112d91906115a7565b92505b50909150505b92915050565b6111446113d8565b61114c6113d8565b82516127109061116190869061ffff1661195c565b61116b919061193a565b815260208301516127109061118590869061ffff1661195c565b61118f919061193a565b60208201526040830151612710906111ac90869061ffff1661195c565b6111b6919061193a565b60408201526080830151612710906111d390869061ffff1661195c565b6111dd919061193a565b608082018190526040820151602083015183516111fa908861197b565b611204919061197b565b61120e919061197b565b611218919061197b565b60608201529392505050565b6040517fe7aa0bd7000000000000000000000000000000000000000000000000000000008152600481018590527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063e7aa0bd790602401600060405180830381600087803b15801561129f57600080fd5b505af11580156112b3573d6000803e3d6000fd5b5050505060005b60058110156113d15760008482600581106112d7576112d76119c3565b602002015111156113c1577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638ede1f05848360058110611323576113236119c3565b602002015186846005811061133a5761133a6119c3565b60200201516040517fffffffff0000000000000000000000000000000000000000000000000000000060e085901b1681526001600160a01b03928316600482015260248101919091529085166044820152606401600060405180830381600087803b1580156113a857600080fd5b505af11580156113bc573d6000803e3d6000fd5b505050505b6113ca81611992565b90506112ba565b5050505050565b6040518060a001604052806005906020820280368337509192915050565b6040518060400160405280600081526020016114106113d8565b905290565b8051611420816119ef565b919050565b600082601f83011261143657600080fd5b6040516040810181811067ffffffffffffffff82111715611459576114596119d9565b806040525080838560408601111561147057600080fd5b6000805b60028110156114a25782518060010b811461148d578283fd5b84526020938401939290920191600101611474565b50929695505050505050565b600082601f8301126114bf57600080fd5b6040516080810181811067ffffffffffffffff821117156114e2576114e26119d9565b6040528083608081018610156114f757600080fd5b60005b60048110156115215761150c8261153c565b835260209283019291909101906001016114fa565b509195945050505050565b8051801515811461142057600080fd5b805161ffff8116811461142057600080fd5b805167ffffffffffffffff8116811461142057600080fd5b60006020828403121561157857600080fd5b8135611583816119ef565b9392505050565b60006020828403121561159c57600080fd5b8151611583816119ef565b600060a082840312156115b957600080fd5b82601f8301126115c857600080fd5b60405160a0810181811067ffffffffffffffff821117156115eb576115eb6119d9565b604052808360a0810186101561160057600080fd5b60005b6005811015611521576116158261153c565b83526020928301929190910190600101611603565b6000806020838503121561163d57600080fd5b823567ffffffffffffffff8082111561165557600080fd5b818501915085601f83011261166957600080fd5b81358181111561167857600080fd5b8660208260051b850101111561168d57600080fd5b60209290920196919550909350505050565b600060a082840312156116b157600080fd5b60405160a0810181811067ffffffffffffffff821117156116d4576116d46119d9565b60405282516116e2816119ef565b81526116f06020840161153c565b60208201526117016040840161152c565b60408201526117126060840161152c565b60608201526117236080840161152c565b60808201529392505050565b6000610200828403121561174257600080fd5b61174a611910565b61175383611415565b81526117616020840161154e565b602082015261177260408401611415565b60408201526117836060840161154e565b606082015261179460808401611415565b608082015260a083015160a08201526117af60c0840161154e565b60c08201526117c060e08401611415565b60e08201526101006117d381850161153c565b908201526101206117e685858301611425565b908201526101606117f9858583016114ae565b6101408301526101e084015181830152508091505092915050565b60006020828403121561182657600080fd5b5035919050565b8060005b6005811015611850578151845260209384019390910190600101611831565b50505050565b80518252602081015161186c602084018261182d565b505050565b6020808252825182820181905260009190848201906040850190845b818110156118b3576118a0838551611856565b9284019260c0929092019160010161188d565b50909695505050505050565b60a08101818360005b60058110156118eb57815161ffff168352602092830192909101906001016118c8565b50505092915050565b60a08101611136828461182d565b60c081016111368284611856565b604051610180810167ffffffffffffffff81118282101715611934576119346119d9565b60405290565b60008261195757634e487b7160e01b600052601260045260246000fd5b500490565b6000816000190483118215151615611976576119766119ad565b500290565b60008282101561198d5761198d6119ad565b500390565b60006000198214156119a6576119a66119ad565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b0381168114611a0457600080fd5b5056fea264697066735822122085515bdc3a8067067f4efc1330f48367e652e40831b9ee7f0e3881433c6080b264736f6c63430008070033",
  "devdoc": {
    "events": {
      "Claim((uint256,uint256[5])[])": {
        "params": {
          "escrows": "data of all escrows that were claimed"
        }
      },
      "SingleClaim((uint256,uint256[5]))": {
        "params": {
          "escrow": "data of the claimed escrow"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "claim(uint256)": {
        "details": "To save everyone's gas costs, it claims balances and fees of all parties that are eligible for a share from the escrow",
        "params": {
          "escrowId": "escrow to be claimed"
        }
      },
      "claimMultiple(uint256[])": {
        "details": "To save everyone's gas costs, it claims balances and fees of all parties that are eligible for a share from the escrow",
        "params": {
          "escrows": "List of escrows to be claimed."
        }
      },
      "constructor": {
        "params": {
          "protocolFeeAddress_": "address to collect protocol fee",
          "unicrowArbitrator_": "arbitration contract",
          "unicrow_": "main escrow contract"
        }
      }
    },
    "title": "Contract for managing claims from Unicrow's escrow",
    "version": 1
  },
  "userdoc": {
    "events": {
      "Claim((uint256,uint256[5])[])": {
        "notice": "Emitted when multiple escrows are claimed"
      },
      "SingleClaim((uint256,uint256[5]))": {
        "notice": "Emitted when a single escrow payment is claimed"
      }
    },
    "kind": "user",
    "methods": {
      "claim(uint256)": {
        "notice": "Claim a single escrow"
      },
      "claimMultiple(uint256[])": {
        "notice": "Claim multiple escrows."
      },
      "protocolFeeAddress()": {
        "notice": "Destination address of the protocol fee (governed)"
      },
      "unicrow()": {
        "notice": "Reference to the main escrow contract (immutable)"
      },
      "unicrowArbitrator()": {
        "notice": "Reference to the Arbitrator contract (immutable)"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 10,
        "contract": "contracts/UnicrowClaim.sol:UnicrowClaim",
        "label": "_status",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 3371,
        "contract": "contracts/UnicrowClaim.sol:UnicrowClaim",
        "label": "crowRewards",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(IUnicrowClaimRewards)5155"
      },
      {
        "astId": 3374,
        "contract": "contracts/UnicrowClaim.sol:UnicrowClaim",
        "label": "stakingRewards",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(IUnicrowStakingRewards)5196"
      },
      {
        "astId": 3377,
        "contract": "contracts/UnicrowClaim.sol:UnicrowClaim",
        "label": "protocolFeeAddress",
        "offset": 0,
        "slot": "3",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(IUnicrowClaimRewards)5155": {
        "encoding": "inplace",
        "label": "contract IUnicrowClaimRewards",
        "numberOfBytes": "20"
      },
      "t_contract(IUnicrowStakingRewards)5196": {
        "encoding": "inplace",
        "label": "contract IUnicrowStakingRewards",
        "numberOfBytes": "20"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}